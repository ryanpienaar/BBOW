
var geometry = ee.Geometry.Polygon(
  [[
    [-91.1464652714206, 46.692168586612084],
    [-90.38016888470185, 46.692168586612084],
    [-90.38016888470185, 47.09195527262986],
    [-91.1464652714206, 47.09195527262986],
    [-91.1464652714206, 46.692168586612084]
  ]],
  null,  // proj (null means default WGS84)
  false  // geodesic
);

// Display AOI
Map.centerObject(geometry, 11);
//Map.addLayer(newdata, {}, 'Point Locations')

// Filter points that fall inside the polygon
var newdata = newdata.filterBounds(geometry)
print('Number of points inside polygon:', newdata.size());



// -----------------------------------
//general functions
// -----------------------------------
var clip= function (image){
  return image.clip(geometry);
};

// -----------------------------------
//cloud mask for HLS
// -----------------------------------
  var cloudMask_HLS = function(image) {
  var qa = image.select('Fmask');
  var cloud = qa.bitwiseAnd(1 << 4)              
                .or(qa.bitwiseAnd(1 << 5))
                .or(qa.bitwiseAnd(1 << 3))
                .or(qa.bitwiseAnd(1 << 1))  
                ;   
  var mask2 = image.mask().reduce(ee.Reducer.min());
  return image
      .updateMask(cloud.not()).updateMask(mask2)
};

//------------------------------------
// Hansen Water mask
//------------------------------------
var hansenImage = ee.Image('UMD/hansen/global_forest_change_2015').select('datamask');
var maskWater = hansenImage.eq(1);

var hansenWaterMask = function(image) {
  image = image.updateMask(maskWater);
  return image;
};

//------------------------------------
// Forest mask
//------------------------------------
// Load NLCD Land Cover for a specific year (e.g., 2019)
var nlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')
  .select('landcover')
  .clip(geometry);

// Define forest class values based on NLCD legend
var forestClasses = [41, 42, 43]; // 41: Deciduous, 42: Evergreen, 43: Mixed Forest

// Create a forest mask
var forestMask = nlcd.remap(forestClasses, [1, 1, 1], 0); // 1 = forest, 0 = non-forest


// -----------------------------------
// phenology threshold
// -----------------------------------
var aoi = geometry
var year = 2020;
var start = ee.Date.fromYMD(year, 1, 1);
var end = ee.Date.fromYMD(year, 12, 31);
var threshold = 0.20;  // EVI threshold for phenology I changed to 0.2 

// -----------------------------------
// EVI
// -----------------------------------
function addEVI(image) {
  var evi = image.expression(
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('B5'),   // NIR
      'RED': image.select('B4'),   // Red
      'BLUE': image.select('B2')   // Blue
    }).rename('EVI');
  return image.addBands(evi).copyProperties(image, ['system:time_start']);
}

// -----------------------------------
// Tassel cap index
// -----------------------------------

// Compute Tasseled Cap for HLS (using OLI coefficients)
function tasseledCap(image) {
  var bands = ['B2','B3','B4','B5','B6','B7']; // Blue, Green, Red, NIR, SWIR1, SWIR2
  var brightness = image.expression(
    '0.3029*B2 + 0.2786*B3 + 0.4733*B4 + 0.5599*B5 + 0.5080*B6 + 0.1872*B7',
    {'B2': image.select('B2'),
     'B3': image.select('B3'),
     'B4': image.select('B4'),
     'B5': image.select('B5'),
     'B6': image.select('B6'),
     'B7': image.select('B7')});

  var greenness = image.expression(
    '-0.2941*B2 -0.2430*B3 -0.5424*B4 +0.7276*B5 +0.0713*B6 -0.1608*B7',
    {'B2': image.select('B2'),
     'B3': image.select('B3'),
     'B4': image.select('B4'),
     'B5': image.select('B5'),
     'B6': image.select('B6'),
     'B7': image.select('B7')});

  var wetness = image.expression(
    '0.1511*B2 +0.1973*B3 +0.3283*B4 +0.3407*B5 -0.7117*B6 -0.4559*B7',
    {'B2': image.select('B2'),
     'B3': image.select('B3'),
     'B4': image.select('B4'),
     'B5': image.select('B5'),
     'B6': image.select('B6'),
     'B7': image.select('B7')});

  return image.addBands([brightness.rename('TCB'),
                         greenness.rename('TCG'),
                         wetness.rename('TCW')]);
}


// -----------------------------------
//change S2-band names
// -----------------------------------
var changeNames = function(img){
  return img.select(['B2', 'B3', 'B4', 'B8', 'B11', 'B12'],['B2', 'B3', 'B4', 'B5', 'B6', 'B7']);
}

// -----------------------------------
// Load and Merge HLSL30 + HLSS30
// -----------------------------------
var hlsl = ee.ImageCollection('NASA/HLS/HLSL30/v002')
  .filterBounds(geometry)                // <<< Spatial filter here
  .filterDate(start, end)
  .map(clip)
  .map(cloudMask_HLS)
  .map(hansenWaterMask)
  .map(addEVI)
  .map(tasseledCap)
  //.select("EVI")
  // .map(function(image) {
  //   return image.updateMask(forestMask);
  // })
  .map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1);
    return img.set('DOY', doy);
  });

var hlss = ee.ImageCollection('NASA/HLS/HLSS30/v002')
  .filterBounds(geometry)                // <<< Spatial filter here
  .filterDate(start, end)
  .map(clip)
  .map(cloudMask_HLS)
  .map(hansenWaterMask)
  .map(changeNames)
  .map(addEVI)
  .map(tasseledCap)
  //.select("EVI")
  // .map(function(image) {
  //   return image.updateMask(forestMask);
  // })
  .map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1);
    return img.set('DOY', doy);
  });

// Merge and sort
var hls = hlsl.merge(hlss).sort('system:time_start');


print("n Images", hls.size())

print("HLS Bands", hls.first().bandNames())


// -------------------------------
// Percentiles
// -------------------------------
var EVI_p90 = hls.reduce(ee.Reducer.percentile([90]))
var EVI_p10 = hls.reduce(ee.Reducer.percentile([10]))

//Map.addLayer(EVI_p10, {}, 'EVIp10')
//Map.addLayer(EVI_p90, {}, 'EVIp90')

// -------------------------------
// Fit Harmonic Model    What does this do?
// -------------------------------
var omega = 2 * Math.PI / 365.25;

function addTimeBands(image) {
  var t = ee.Date(image.get('system:time_start')).difference(start, 'day');
  var time = ee.Image.constant(t).float().rename('t');
  var sin = time.multiply(omega).sin().rename('sin');
  var cos = time.multiply(omega).cos().rename('cos');
  return image.addBands([time, sin, cos]);
}

var harmonicInputs = hls.map(addTimeBands);

var harmonicFit = harmonicInputs.select(['t', 'sin', 'cos', 'EVI'])
  .reduce(ee.Reducer.linearRegression({
    numX: 3,
    numY: 1
  }));

var coeffs = harmonicFit.select('coefficients')
  .arrayProject([0])
  .arrayFlatten([['a', 'b', 'c']]);

//print('Harmonic Coefficients:', coeffs);

// -------------------------------
//Predict EVI Using Harmonic Model
// -------------------------------
function predictEVI(day) {
  var t = ee.Image.constant(day).float();
  var sin = t.multiply(omega).sin();
  var cos = t.multiply(omega).cos();

  var pred = coeffs.select('a')
    .add(coeffs.select('b').multiply(sin))
    .add(coeffs.select('c').multiply(cos))
    .rename('EVI');

  return pred.set('system:time_start', start.advance(day, 'day').millis());
}

var days = ee.List.sequence(0, 364, 8);  // every 8 days 
var fittedEVI_HM = ee.ImageCollection.fromImages(days.map(predictEVI))
.map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1); // 1-based DOY
    return img.set('DOY', doy);
  });
// -------------------------------
// Fit Harmonic Model    What does this do?
// -------------------------------
var omega = 2 * Math.PI / 365.25;

function addTimeBands(image) {
  var t = ee.Date(image.get('system:time_start')).difference(start, 'day');
  var time = ee.Image.constant(t).float().rename('t');
  var sin = time.multiply(omega).sin().rename('sin');
  var cos = time.multiply(omega).cos().rename('cos');
  return image.addBands([time, sin, cos]);
}

var harmonicInputs = hls.map(addTimeBands);

var harmonicFit = harmonicInputs.select(['t', 'sin', 'cos', 'EVI'])
  .reduce(ee.Reducer.linearRegression({
    numX: 3,
    numY: 1
  }));

var coeffs = harmonicFit.select('coefficients')
  .arrayProject([0])
  .arrayFlatten([['a', 'b', 'c']]);

//print('Harmonic Coefficients:', coeffs);

// -------------------------------
//Predict EVI Using Harmonic Model
// -------------------------------
function predictEVI(day) {
  var t = ee.Image.constant(day).float();
  var sin = t.multiply(omega).sin();
  var cos = t.multiply(omega).cos();

  var pred = coeffs.select('a')
    .add(coeffs.select('b').multiply(sin))
    .add(coeffs.select('c').multiply(cos))
    .rename('EVI');

  return pred.set('system:time_start', start.advance(day, 'day').millis());
}

var days = ee.List.sequence(0, 364, 8);  // every 8 days 
var fittedEVI_HM = ee.ImageCollection.fromImages(days.map(predictEVI))
.map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1); // 1-based DOY
    return img.set('DOY', doy);
  });

//Map.addLayer(fittedEVI_HM)

// Add time as a band for each image
var fittedWithTime = fittedEVI_HM.map(function(img) {
  var t = ee.Date(img.get('system:time_start')).difference(start, 'day');
  var timeBand = ee.Image.constant(t).float().rename('time');
  return img.addBands(timeBand);
});




// Mask where EVI is below threshold
var aboveThreshold = fittedWithTime.map(function(img) {
  return img.updateMask(img.select('EVI').gt(threshold));
});

// SOS: earliest date EVI > threshold
var sos = aboveThreshold.select('time').min();

// EOS: latest date EVI > threshold
var eos = aboveThreshold.select('time').max();

// POS: date of max EVI
var pos = fittedWithTime.qualityMosaic('EVI').select('time');

// Peak EVI value
var peakEVI = fittedWithTime.qualityMosaic('EVI').select('EVI');

// Length of Season
var los = eos.subtract(sos).rename('LOS');


// Add SOS to map with dynamic scaling
// Map.addLayer(sos, {
//   min: 100,
//   max: 200,
//   palette: ['purple', 'blue', 'green', 'yellow', 'orange', 'red']
// }, 'Start of Season (DOY)');




// Map.addLayer(sos, {}, 'SOS')
// Map.addLayer(eos, {}, 'EOS')
// Map.addLayer(los, {}, 'LOS')

// ---------------------------------------------
// Bands in Classification
//----------------------------------------------
var seasonMetrics = sos.rename('SOS')
  .addBands(eos.rename('EOS'))
  .addBands(pos.rename('POS'))
  .addBands(peakEVI.rename('PeakEVI'))
  .addBands(los); 
  
// Add EVI metrics too
// Compute mean EVI
var meanEVI = fittedWithTime.select('EVI').mean().rename('EVI_mean');

// Compute standard deviation of EVI
var stdEVI = fittedWithTime.select('EVI').reduce(ee.Reducer.stdDev()).rename('EVI_stdDev');

// Compute range (max - min)
var maxEVI = fittedWithTime.select('EVI').max();
var minEVI = fittedWithTime.select('EVI').min();
var rangeEVI = maxEVI.subtract(minEVI).rename('EVI_range');

seasonMetrics = seasonMetrics
  .addBands(meanEVI)
  .addBands(stdEVI)
  .addBands(rangeEVI)
  .addBands(maxEVI)
  .addBands(minEVI);
  
// Define the bands you want to compute range for
var bands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', "TCB", 'TCG', 'TCW'];

// Function to calculate mean, stdDev, and range for a single band
var summarizeBand = function(band) {
  var selected = hls.select(band);
  var mean = selected.mean().rename(band + '_mean');
  var stdDev = selected.reduce(ee.Reducer.stdDev()).rename(band + '_stdDev');
  var range = selected.max().subtract(selected.min()).rename(band + '_range');
  return ee.Image.cat([mean, stdDev, range]);
};

// Apply function to all bands and combine into one image
var summaryBands = ee.Image.cat(
  bands.map(summarizeBand)
);

// Add the summary stats to your existing seasonMetrics image
seasonMetrics = seasonMetrics.addBands(summaryBands);
  
//seasonMetrics = seasonMetrics.select("EVI_mean", "SOS", "EOS", "PeakEVI", "POS", "LOS")
  
print('Bands:', seasonMetrics.bandNames());
//Map.addLayer(seasonMetrics, {}, "seasonMetrics")

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


var points = newdata

// Add a random value column (between 0 and 1)
var withRandom = points.randomColumn('random',42);

// Define training and testing sets
var trainingPoints = withRandom.filter(ee.Filter.lt('random', 0.7));  // 70%
var testingPoints = withRandom.filter(ee.Filter.gte('random', 0.7));  // 30%

// print('trainingPoints', trainingPoints)
// print('testingPoints', testingPoints)


// Define color palette
var palette = ['white', 'green'];

// ---------------------------------------------
// Dominance Map
// ---------------------------------------------
// Define your species list
var speciesList = ["Aspen", "Maple", "Oak", "Birch", "Hemlock", "Pine", "Cedar", "Ash"];
var speciesList = [ "Maple", "Oak"];

// Define color palette
var palette = ['white', 'green'];

// Create an empty object to store predictions
var predictionLayers = {};  // This is a plain JS object

speciesList.forEach(function(species) {

  // -----------------------
// 1. Prepare training data
// -----------------------
var training = seasonMetrics.sampleRegions({
  collection: trainingPoints,
  properties: [species],
  scale: 30
});

//print('training', training)

// Create a binary presence/absence column
// (assuming species column is proportion between 0â€“1)
var trainingPA = training.map(function(f) {
  var pa = ee.Number(f.get(species)).gt(0).int(); // ensures 0 or 1 integer
  return f.set('presence', pa);
});

  print('TrainingPA', trainingPA)

// -----------------------
// 2. Stage 1: Classification model (presence/absence)
// -----------------------


var rfClass = ee.Classifier.smileRandomForest(50)
  .setOutputMode('PROBABILITY')  
  .train({
    features: trainingPA,
    classProperty: 'presence',
    inputProperties: seasonMetrics.bandNames()
  });

// Predict probability of oak presence, remove this line when using rf CLASSIFICATION
var probPresenceProp = seasonMetrics.classify(rfClass).rename(species + '_prop');

var probPresence = probPresenceProp.gt(0.35).rename(species + '_pred');

// Add prediction layer to the map
Map.addLayer(probPresence, 
            {min: 0, max: 1, palette: ['white', 'green']}, 
            species + ' Probability of Presence');



/////////////////////////////////////////////////////////////////////

// Sample BOTH probability and thresholded prediction
var test = probPresenceProp.addBands(probPresence).sampleRegions({
  collection: testingPoints,
  properties: [species],
  scale: 30
});

// Add observed presence as 0/1
var testPA = test.map(function(f) {
  var obs = ee.Number(f.get(species)).gt(0).int();  // 0 or 1
  return f.set(species + '_obs', obs);
});
////////////////////////////////////////////////////////////////////

//print("Test", test)
//print("TestPA", testPA)


//Build confusion matrix
var confusionMatrix = testPA.errorMatrix(species+ '_obs', species+ '_pred');
print('Confusion Matrix ' +species, confusionMatrix);
print('Presence Accuracy ' +species, confusionMatrix.accuracy());
print('Kappa ' +species, confusionMatrix.kappa());
print('Producers Accuracy ' +species, confusionMatrix.producersAccuracy());
print('Users Accuracy ' +species, confusionMatrix.consumersAccuracy());

// Build confusion matrix
var confusionMatrix = testPA.errorMatrix(species + '_obs', species + '_pred');

// Wrap metrics into a Feature
var metrics = ee.Feature(null, {
  species: species,
  overall_accuracy: confusionMatrix.accuracy(),
  kappa: confusionMatrix.kappa(),
  //producers_accuracy: confusionMatrix.producersAccuracy().toDictionary(),
  //users_accuracy: confusionMatrix.consumersAccuracy().toDictionary(),
  matrix: confusionMatrix.array()  // confusion matrix as array
});

// Make it a FeatureCollection
var metricsFC = ee.FeatureCollection([metrics]);

// Export to Drive
Export.table.toDrive({
  collection: metricsFC,
  description: 'ConfusionMatrix_' + species,
  folder: 'BBOW/EE',
  fileNamePrefix: 'confusionMatrix_' + species,
  fileFormat: 'CSV'
});


// -----------------------
// 3. Stage 2: Regression model (only where proportion > 0)
// -----------------------
print("Training "+species, training)
print("Prob presence "+ species, probPresence)

var present = seasonMetrics.addBands(probPresence).sampleRegions({
  collection: trainingPoints,
  //reducer: ee.Reducer.first(),
  properties: [species],
  scale:  30
});

print("new present "+ species, present)

var presentOnes = present.filter(ee.Filter.eq(species +"_pred", 1));

// Inspect
print('Filtered present', presentOnes);

//var trainingPositive = training.filter(ee.Filter.gt(species, 0));

var trainingPositive = presentOnes

var rfReg = ee.Classifier.smileRandomForest(1000)
  .setOutputMode('REGRESSION')
  .train({
    features: trainingPositive,
    classProperty: species,
    inputProperties: seasonMetrics.bandNames()
  });

// Predict oak proportion (conditional on presence)
var regPrediction = seasonMetrics.classify(rfReg).rename(species + '_reg');

// -----------------------
// 4. Combine stage 1 & stage 2
// -----------------------
// Final prediction = prob(presence) * predicted proportion
var finalPrediction = probPresence.multiply(regPrediction).rename(species + '_pred');

var prediction = finalPrediction;

  // Visualize
  Map.addLayer(prediction, {min: 0, max: 1, palette: palette}, 'Predicted ' + species);
  
  ///////////////////////////////////////////////////////////////
//////////////// Add a legend/////////////////////////////////

var min = 0;
var max = 1;

// Create a panel for the legend
var legend = ui.Panel({
  style: {
    position: 'bottom-left',
    padding: '8px 15px'
  }
});

// Add a title
var legendTitle = ui.Label({
  value: 'Predicted ' + species,
  style: {fontWeight: 'bold', fontSize: '14px', margin: '0 0 4px 0', padding: '0'}
});
legend.add(legendTitle);

// Create the colorbar using a thumbnail
var lon = ee.Image.pixelLonLat().select('longitude');
var gradient = lon.multiply((max - min) / 100.0).add(min);

var legendImage = gradient.visualize({min: min, max: max, palette: palette});
var thumbnail = ui.Thumbnail({
  image: legendImage,
  params: {bbox:'0,0,100,10', dimensions:'100x10'},
  style: {stretch: 'horizontal', margin: '0px 8px', maxHeight: '24px'}
});

// Add colorbar to panel
legend.add(thumbnail);

// Add min & max labels
var labels = ui.Panel({
  widgets: [
    ui.Label(min, {margin: '4px 8px'}),
    ui.Label(max, {margin: '4px 8px', textAlign: 'right', stretch: 'horizontal'})
  ],
  layout: ui.Panel.Layout.flow('horizontal')
});
legend.add(labels);

// Add legend to the map
Map.add(legend);

//////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
  
  // Export binary presence/absence raster (0/1)
Export.image.toDrive({
  image: probPresence,
  description: species + '_presenceAbsence',
  folder: 'BBOW/EE',
  fileNamePrefix: species + '_presenceAbsence',
  scale: 30,
  region: aoi,
  maxPixels: 1e13
});

  // Variable importance
  var importance = ee.Dictionary(rfReg.explain().get('importance'));
  print('Variable importance: ' + species, importance);

  // Evaluate on testing data
  var testing = seasonMetrics.sampleRegions({
    collection: testingPoints,
    properties: [species],
    scale: 30
  });

  var predictedTest = testing.classify(rfReg);
  var withError = predictedTest.map(function(f) {
    var observed = ee.Number(f.get(species));
    var pred = ee.Number(f.get('classification'));
    var squaredError = observed.subtract(pred).pow(2);
    return f.set('squaredError', squaredError);
  });

  var mse = withError.aggregate_mean('squaredError');
  //print('MSE for ' + species + ':', mse);
  var rmse = ee.Number(mse).sqrt();
 print('RMSE for ' + species + ':', rmse);
  
  
  // R squared testing
  var test = prediction.sampleRegions({
    collection: testingPoints,
    properties: [species],
    scale: 30
  });

//print(test)

var chart = ui.Chart.feature.byFeature({
  features: test,
  xProperty: species,
  yProperties: [species + "_pred"]
})
.setChartType('ScatterChart')
.setOptions({
  title: 'Observed vs Predicted',
  hAxis: {title: 'Observed '+species +' proportion'},
  vAxis: {title: 'Predicted classification'},
  pointSize: 4,
  trendlines: {0: {showR2: true, visibleInLegend: true}} // adds regression line
});  
 
// Export scatterplot data (Observed vs Predicted)
Export.table.toDrive({
  collection: test,
  description: 'ObsVsPred_' + species,
  folder: 'BBOW/EE',
  fileNamePrefix: 'ObsVsPred_' + species,
  fileFormat: 'CSV'
});

 
print(chart)


});



  
  
