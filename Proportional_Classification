

// Display AOI
Map.centerObject(geometry, 11);
Map.addLayer(newdata, {}, 'Point Locations')

// Filter points that fall inside the polygon
var newdata = newdata.filterBounds(geometry)
print('Number of points inside polygon:', newdata.size());



// -----------------------------------
//general functions
// -----------------------------------
var clip= function (image){
  return image.clip(geometry);
};

// -----------------------------------
//cloud mask for HLS
// -----------------------------------
  var cloudMask_HLS = function(image) {
  var qa = image.select('Fmask');
  var cloud = qa.bitwiseAnd(1 << 4)              
                .or(qa.bitwiseAnd(1 << 5))
                .or(qa.bitwiseAnd(1 << 3))
                .or(qa.bitwiseAnd(1 << 1))  
                ;   
  var mask2 = image.mask().reduce(ee.Reducer.min());
  return image
      .updateMask(cloud.not()).updateMask(mask2)
};

//------------------------------------
// Hansen Water mask
//------------------------------------
var hansenImage = ee.Image('UMD/hansen/global_forest_change_2015').select('datamask');
var maskWater = hansenImage.eq(1);

var hansenWaterMask = function(image) {
  image = image.updateMask(maskWater);
  return image;
};

//------------------------------------
// Forest mask
//------------------------------------
// Load NLCD Land Cover for a specific year (e.g., 2019)
var nlcd = ee.Image('USGS/NLCD_RELEASES/2019_REL/NLCD/2019')
  .select('landcover')
  .clip(geometry);

// Define forest class values based on NLCD legend
var forestClasses = [41, 42, 43]; // 41: Deciduous, 42: Evergreen, 43: Mixed Forest

// Create a forest mask
var forestMask = nlcd.remap(forestClasses, [1, 1, 1], 0); // 1 = forest, 0 = non-forest


// -----------------------------------
// phenology threshold
// -----------------------------------
var aoi = geometry
var year = 2023;
var start = ee.Date.fromYMD(year, 1, 1);
var end = ee.Date.fromYMD(year, 12, 31);
var threshold = 0.20;  // EVI threshold for phenology I changed to 0.2 

// -----------------------------------
// EVI
// -----------------------------------
function addEVI(image) {
  var evi = image.expression(
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('B5'),   // NIR
      'RED': image.select('B4'),   // Red
      'BLUE': image.select('B2')   // Blue
    }).rename('EVI');
  return image.addBands(evi).copyProperties(image, ['system:time_start']);
}

// -----------------------------------
// Tassel cap index
// -----------------------------------

// Compute Tasseled Cap for HLS (using OLI coefficients)
function tasseledCap(image) {
  var bands = ['B2','B3','B4','B5','B6','B7']; // Blue, Green, Red, NIR, SWIR1, SWIR2
  var brightness = image.expression(
    '0.3029*B2 + 0.2786*B3 + 0.4733*B4 + 0.5599*B5 + 0.5080*B6 + 0.1872*B7',
    {'B2': image.select('B2'),
     'B3': image.select('B3'),
     'B4': image.select('B4'),
     'B5': image.select('B5'),
     'B6': image.select('B6'),
     'B7': image.select('B7')});

  var greenness = image.expression(
    '-0.2941*B2 -0.2430*B3 -0.5424*B4 +0.7276*B5 +0.0713*B6 -0.1608*B7',
    {'B2': image.select('B2'),
     'B3': image.select('B3'),
     'B4': image.select('B4'),
     'B5': image.select('B5'),
     'B6': image.select('B6'),
     'B7': image.select('B7')});

  var wetness = image.expression(
    '0.1511*B2 +0.1973*B3 +0.3283*B4 +0.3407*B5 -0.7117*B6 -0.4559*B7',
    {'B2': image.select('B2'),
     'B3': image.select('B3'),
     'B4': image.select('B4'),
     'B5': image.select('B5'),
     'B6': image.select('B6'),
     'B7': image.select('B7')});

  return image.addBands([brightness.rename('TCB'),
                         greenness.rename('TCG'),
                         wetness.rename('TCW')]);
}


// -----------------------------------
//change S2-band names
// -----------------------------------
var changeNames = function(img){
  return img.select(['B2', 'B3', 'B4', 'B8', 'B11', 'B12'],['B2', 'B3', 'B4', 'B5', 'B6', 'B7']);
}

// -----------------------------------
// Load and Merge HLSL30 + HLSS30
// -----------------------------------
var hlsl = ee.ImageCollection('NASA/HLS/HLSL30/v002')
  .filterBounds(geometry)                // <<< Spatial filter here
  .filterDate(start, end)
  .map(clip)
  .map(cloudMask_HLS)
  .map(hansenWaterMask)
  .map(addEVI)
  .map(tasseledCap)
  //.select("EVI")
  // .map(function(image) {
  //   return image.updateMask(forestMask);
  // })
  .map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1);
    return img.set('DOY', doy);
  });

var hlss = ee.ImageCollection('NASA/HLS/HLSS30/v002')
  .filterBounds(geometry)                // <<< Spatial filter here
  .filterDate(start, end)
  .map(clip)
  .map(cloudMask_HLS)
  .map(hansenWaterMask)
  .map(changeNames)
  .map(addEVI)
  .map(tasseledCap)
  //.select("EVI")
  // .map(function(image) {
  //   return image.updateMask(forestMask);
  // })
  .map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1);
    return img.set('DOY', doy);
  });

// Merge and sort
var hls = hlsl.merge(hlss).sort('system:time_start');


print("n Images", hls.size())

print("HLS Bands", hls.first().bandNames())


// -------------------------------
// Percentiles
// -------------------------------
var EVI_p90 = hls.reduce(ee.Reducer.percentile([90]))
var EVI_p10 = hls.reduce(ee.Reducer.percentile([10]))

//Map.addLayer(EVI_p10, {}, 'EVIp10')
//Map.addLayer(EVI_p90, {}, 'EVIp90')

// -------------------------------
// Fit Harmonic Model    What does this do?
// -------------------------------
var omega = 2 * Math.PI / 365.25;

function addTimeBands(image) {
  var t = ee.Date(image.get('system:time_start')).difference(start, 'day');
  var time = ee.Image.constant(t).float().rename('t');
  var sin = time.multiply(omega).sin().rename('sin');
  var cos = time.multiply(omega).cos().rename('cos');
  return image.addBands([time, sin, cos]);
}

var harmonicInputs = hls.map(addTimeBands);

var harmonicFit = harmonicInputs.select(['t', 'sin', 'cos', 'EVI'])
  .reduce(ee.Reducer.linearRegression({
    numX: 3,
    numY: 1
  }));

var coeffs = harmonicFit.select('coefficients')
  .arrayProject([0])
  .arrayFlatten([['a', 'b', 'c']]);

//print('Harmonic Coefficients:', coeffs);

// -------------------------------
//Predict EVI Using Harmonic Model
// -------------------------------
function predictEVI(day) {
  var t = ee.Image.constant(day).float();
  var sin = t.multiply(omega).sin();
  var cos = t.multiply(omega).cos();

  var pred = coeffs.select('a')
    .add(coeffs.select('b').multiply(sin))
    .add(coeffs.select('c').multiply(cos))
    .rename('EVI');

  return pred.set('system:time_start', start.advance(day, 'day').millis());
}

var days = ee.List.sequence(0, 364, 8);  // every 8 days 
var fittedEVI_HM = ee.ImageCollection.fromImages(days.map(predictEVI))
.map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1); // 1-based DOY
    return img.set('DOY', doy);
  });
// -------------------------------
// Fit Harmonic Model    What does this do?
// -------------------------------
var omega = 2 * Math.PI / 365.25;

function addTimeBands(image) {
  var t = ee.Date(image.get('system:time_start')).difference(start, 'day');
  var time = ee.Image.constant(t).float().rename('t');
  var sin = time.multiply(omega).sin().rename('sin');
  var cos = time.multiply(omega).cos().rename('cos');
  return image.addBands([time, sin, cos]);
}

var harmonicInputs = hls.map(addTimeBands);

var harmonicFit = harmonicInputs.select(['t', 'sin', 'cos', 'EVI'])
  .reduce(ee.Reducer.linearRegression({
    numX: 3,
    numY: 1
  }));

var coeffs = harmonicFit.select('coefficients')
  .arrayProject([0])
  .arrayFlatten([['a', 'b', 'c']]);

//print('Harmonic Coefficients:', coeffs);

// -------------------------------
//Predict EVI Using Harmonic Model
// -------------------------------
function predictEVI(day) {
  var t = ee.Image.constant(day).float();
  var sin = t.multiply(omega).sin();
  var cos = t.multiply(omega).cos();

  var pred = coeffs.select('a')
    .add(coeffs.select('b').multiply(sin))
    .add(coeffs.select('c').multiply(cos))
    .rename('EVI');

  return pred.set('system:time_start', start.advance(day, 'day').millis());
}

var days = ee.List.sequence(0, 364, 8);  // every 8 days 
var fittedEVI_HM = ee.ImageCollection.fromImages(days.map(predictEVI))
.map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year').add(1); // 1-based DOY
    return img.set('DOY', doy);
  });

//Map.addLayer(fittedEVI_HM)

// Add time as a band for each image
var fittedWithTime = fittedEVI_HM.map(function(img) {
  var t = ee.Date(img.get('system:time_start')).difference(start, 'day');
  var timeBand = ee.Image.constant(t).float().rename('time');
  return img.addBands(timeBand);
});


// Mask where EVI is below threshold
var aboveThreshold = fittedWithTime.map(function(img) {
  return img.updateMask(img.select('EVI').gt(threshold));
});

// SOS: earliest date EVI > threshold
var sos = aboveThreshold.select('time').min();

// EOS: latest date EVI > threshold
var eos = aboveThreshold.select('time').max();

// POS: date of max EVI
var pos = fittedWithTime.qualityMosaic('EVI').select('time');

// Peak EVI value
var peakEVI = fittedWithTime.qualityMosaic('EVI').select('EVI');

// Length of Season
var los = eos.subtract(sos).rename('LOS');


// Add SOS to map with dynamic scaling
// Map.addLayer(sos, {
//   min: 100,
//   max: 200,
//   palette: ['purple', 'blue', 'green', 'yellow', 'orange', 'red']
// }, 'Start of Season (DOY)');




// Map.addLayer(sos, {}, 'SOS')
// Map.addLayer(eos, {}, 'EOS')
// Map.addLayer(los, {}, 'LOS')

// ---------------------------------------------
// Bands in Classification
//----------------------------------------------
var seasonMetrics = sos.rename('SOS')
  .addBands(eos.rename('EOS'))
  .addBands(pos.rename('POS'))
  .addBands(peakEVI.rename('PeakEVI'))
  .addBands(los); 
  
// Add EVI metrics too
// Compute mean EVI
var meanEVI = fittedWithTime.select('EVI').mean().rename('EVI_mean');

// Compute standard deviation of EVI
var stdEVI = fittedWithTime.select('EVI').reduce(ee.Reducer.stdDev()).rename('EVI_stdDev');

// Compute range (max - min)
var maxEVI = fittedWithTime.select('EVI').max();
var minEVI = fittedWithTime.select('EVI').min();
var rangeEVI = maxEVI.subtract(minEVI).rename('EVI_range');

seasonMetrics = seasonMetrics
  .addBands(meanEVI)
  .addBands(stdEVI)
  .addBands(rangeEVI)
  .addBands(maxEVI)
  .addBands(minEVI);
  
// Define the bands you want to compute range for
var bands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', "TCB", 'TCG', 'TCW'];

// Function to calculate mean, stdDev, and range for a single band
var summarizeBand = function(band) {
  var selected = hls.select(band);
  var mean = selected.mean().rename(band + '_mean');
  var stdDev = selected.reduce(ee.Reducer.stdDev()).rename(band + '_stdDev');
  var range = selected.max().subtract(selected.min()).rename(band + '_range');
  return ee.Image.cat([mean, stdDev, range]);
};

// Apply function to all bands and combine into one image
var summaryBands = ee.Image.cat(
  bands.map(summarizeBand)
);

// Add the summary stats to your existing seasonMetrics image
seasonMetrics = seasonMetrics.addBands(summaryBands);
  
//seasonMetrics = seasonMetrics.select("EVI_mean", "SOS", "EOS", "PeakEVI", "POS", "LOS")
  
print('Bands:', seasonMetrics.bandNames());
//Map.addLayer(seasonMetrics, {}, "seasonMetrics")

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


// ---------------------------------------------
// Dominance Map
// ---------------------------------------------


// Define color palette
var palette = ['white', 'green'];

// Create an empty object to store predictions
var predictionLayers = {};  // This is a plain JS object


// Define your species list
var speciesList = ["Aspen", "Maple", "Oak", "Birch", "Hemlock", "Pine", "Cedar", "Ash"];
var speciesList = [ "Oak"];

speciesList.forEach(function(species) {

// var points = newdata


// // Add lat/lon as properties if they don't already exist
//   var withCoords = newdata.map(function(f) {
//     var coords = f.geometry().coordinates();
//     return f.set({
//       longitude: coords.get(0),
//       latitude: coords.get(1)
//     });
//   });

//   // Keep only ID, coordinates, and the current species property
//   var keepProps = ['ID', 'longitude', 'latitude', species];
//   var points = withCoords.map(function(f) {
//     return f.select(keepProps);
//   });
  
//   // Add presence/absence property (1 if > 0, else 0)
//   var pointsPA = points.map(function(f) {
//     var pa = ee.Number(f.get(species)).gt(0).int();
//     return f.set(species +' Obs_Presence', pa);
//   });

//   //print(species + ' subset points:', pointsPA);
//   //print(species + ' subset property names:', points.first().propertyNames());
  
//   // Split into presence and absence
//   var presence = pointsPA.filter(ee.Filter.eq(species+' Obs_Presence', 1));
//   var absence  = pointsPA.filter(ee.Filter.eq(species+' Obs_Presence', 0));

//   // Count both
//   var nPresence = presence.size();
//   var nAbsence  = absence.size();
//   //print(species + ' presence count:', nPresence);
//   //print(species + ' absence count:', nAbsence);

//   // Sample equal number of each (based on the smaller group)
//   var nSamples = nPresence.min(nAbsence);

//   var presenceSample = presence.randomColumn('rand').sort('rand').limit(nSamples);
//   var absenceSample  = absence.randomColumn('rand').sort('rand').limit(nSamples);

//   // Merge balanced set
//   var balancedPoints = presenceSample.merge(absenceSample);

//   //print(species + ' balanced dataset:', balancedPoints);
//   //print(species + ' balanced size:', balancedPoints.size());
  
// var data = seasonMetrics.sampleRegions({
//     collection: balancedPoints,
//     //properties: ['ID', 'longitude', 'latitude', species, species + '_Obs_Presence'],
//     scale: 30,
//     geometries: true
//   });



// var withRandom = data.randomColumn('random', 42)

// // Define training and testing sets
// var trainingPoints = withRandom.filter(ee.Filter.lt('random', 0.7));  // 70%
// var testingPoints = withRandom.filter(ee.Filter.gte('random', 0.7));  // 30%

// ------------------------------------------------------
// Step 1: Prepare point data with coordinates + PA
// ------------------------------------------------------
var withCoords = newdata.map(function(f) {
  var coords = f.geometry().coordinates();
  return f.set({
    longitude: coords.get(0),
    latitude: coords.get(1)
  });
});

var keepProps = ['ID', 'longitude', 'latitude', species];
var points = withCoords.map(function(f) {
  return f.select(keepProps);
});

var pointsPA = points.map(function(f) {
  var pa = ee.Number(f.get(species)).gt(0).int();
  return f.set(species + ' Obs_Presence', pa);
});

// ------------------------------------------------------
// Step 2: Sample seasonMetrics at point locations
// ------------------------------------------------------
var sampledPoints = seasonMetrics.sampleRegions({
  collection: pointsPA,
  scale: 30,
  geometries: true
});

// ------------------------------------------------------
// Step 3: Balance presence/absence counts
// ------------------------------------------------------
var presence = sampledPoints.filter(ee.Filter.eq(species + ' Obs_Presence', 1));
var absence  = sampledPoints.filter(ee.Filter.eq(species + ' Obs_Presence', 0));

var nPresence = presence.size();
var nAbsence  = absence.size();
var nSamples  = nPresence.min(nAbsence);

var presenceSample = presence.randomColumn('rand').sort('rand').limit(nSamples);
var absenceSample  = absence.randomColumn('rand').sort('rand').limit(nSamples);

var balancedPoints = presenceSample.merge(absenceSample);

// ------------------------------------------------------
// Step 4: Split into training/testing sets (random 70/30)
// ------------------------------------------------------
balancedPoints = balancedPoints.randomColumn('rand', 42);
var split = 0.7;
var trainingPoints = balancedPoints.filter(ee.Filter.lt('rand', split));
var testingPoints  = balancedPoints.filter(ee.Filter.gte('rand', split));

// ------------------------------------------------------
// Step 5: Show counts by class in training/testing sets
// ------------------------------------------------------

// Count presence/absence for training
var trainCounts = trainingPoints.aggregate_histogram(species + ' Obs_Presence');
var testCounts  = testingPoints.aggregate_histogram(species + ' Obs_Presence');

// print('Training points by class (0=absence, 1=presence):', trainCounts);
// print('Testing points by class (0=absence, 1=presence):', testCounts);

// Optionally, individual totals:
// print('Total training points:', trainingPoints.size());
// print('Total testing points:', testingPoints.size());


// ----------------------
// RF accuracy vs nTrees
// ----------------------



// -------------------------------
// Step 1: Tune numberOfTrees
// -------------------------------
var nTreeList = ee.List.sequence(50, 2000, 50);

var resultsTrees = nTreeList.map(function(nt) {
  nt = ee.Number(nt);
  
  var rfClass = ee.Classifier.smileRandomForest({
    numberOfTrees: nt,
    variablesPerSplit: 10, // fixed for now
    minLeafPopulation: 3,
    bagFraction: 0.6
  })
  .setOutputMode('PROBABILITY')
  .train({
    features: trainingPoints,
    classProperty: species + ' Obs_Presence',
    inputProperties: seasonMetrics.bandNames()
  });

  var probPresence = seasonMetrics.classify(rfClass).rename(species + '_prop_prediction');
  var binaryPred = probPresence.gt(0.7).rename(species + '_binary_prediction');

  var test = binaryPred.sampleRegions({
    collection: testingPoints,
    properties: [species + ' Obs_Presence'],
    scale: 30,
    geometries: true
  });

  var confusion = test.errorMatrix(species + ' Obs_Presence', species + '_binary_prediction');
  var acc = confusion.accuracy();
  var kappa = confusion.kappa();

  return ee.Feature(null, {nTrees: nt, Accuracy: acc, Kappa: kappa});
});

var resultsTreesFC = ee.FeatureCollection(resultsTrees);
//print('Tuning nTrees results:', resultsTreesFC);

// // Plot accuracy & kappa vs number of trees
// var chartTrees = ui.Chart.feature.byFeature({
//   features: resultsTreesFC,
//   xProperty: 'nTrees',
//   yProperties: ['Accuracy', 'Kappa']
// }).setOptions({
//   title: 'RF Performance vs Number of Trees',
//   hAxis: {title: 'Number of Trees'},
//   vAxis: {title: 'Metric Value'},
//   colors: ['blue', 'red']
// });
// print(chartTrees);

// Extract best number of trees based on highest accuracy
var bestTrees = resultsTreesFC.sort('Accuracy', false).first().get('nTrees');
// print('Best number of trees:', bestTrees);



// -----------------------------------
// Step 2: Tune variablesPerSplit
// -----------------------------------
var varsList = ee.List.sequence(1, 20, 1);

var resultsVars = varsList.map(function(vs) {
  vs = ee.Number(vs);
  
  var rfClass = ee.Classifier.smileRandomForest({
    numberOfTrees: bestTrees,
    variablesPerSplit: vs,
    minLeafPopulation: 3,
    bagFraction: 0.6
  })
  .setOutputMode('PROBABILITY')
  .train({
    features: trainingPoints,
    classProperty: species + ' Obs_Presence',
    inputProperties: seasonMetrics.bandNames()
  });

  var probPresence = seasonMetrics.classify(rfClass).rename(species + '_prop_prediction');
  var binaryPred = probPresence.gt(0.7).rename(species + '_binary_prediction');

  var test = binaryPred.sampleRegions({
    collection: testingPoints,
    properties: [species + ' Obs_Presence'],
    scale: 30,
    geometries: true
  });

  var confusion = test.errorMatrix(species + ' Obs_Presence', species + '_binary_prediction');
  var acc = confusion.accuracy();
  var kappa = confusion.kappa();

  return ee.Feature(null, {variablesPerSplit: vs, Accuracy: acc, Kappa: kappa});
});

var resultsVarsFC = ee.FeatureCollection(resultsVars);
//print('Tuning variablesPerSplit results:', resultsVarsFC);

// Plot accuracy & kappa vs variablesPerSplit
// var chartVars = ui.Chart.feature.byFeature({
//   features: resultsVarsFC,
//   xProperty: 'variablesPerSplit',
//   yProperties: ['Accuracy', 'Kappa']
// }).setOptions({
//   title: 'RF Performance vs Variables per Split',
//   hAxis: {title: 'Variables per Split'},
//   vAxis: {title: 'Metric Value'},
//   colors: ['green', 'orange']
// });
// print(chartVars);

// Get best variablesPerSplit
var bestVars = resultsVarsFC.sort('Accuracy', false).first().get('variablesPerSplit');
// print('Best variablesPerSplit:', bestVars);

// --------------------------------------
// Step 3: Tune minLeafPopulation
// --------------------------------------
var minLeafList = ee.List.sequence(1, 10, 1);

var resultsLeaf = minLeafList.map(function(ml) {
  ml = ee.Number(ml);
  
  var rf = ee.Classifier.smileRandomForest({
    numberOfTrees: bestTrees,
    variablesPerSplit: bestVars,
    minLeafPopulation: ml,
    bagFraction: 0.6
  })
  .setOutputMode('PROBABILITY')
  .train({
    features: trainingPoints,
    classProperty: species + ' Obs_Presence',
    inputProperties: seasonMetrics.bandNames()
  });
  
  var binaryPred = seasonMetrics.classify(rf)
    .gt(0.7)
    .rename(species + '_binary_prediction');
  
  var test = binaryPred.sampleRegions({
    collection: testingPoints,
    properties: [species + ' Obs_Presence'],
    scale: 30
  });
  
  var confusion = test.errorMatrix(species + ' Obs_Presence', species + '_binary_prediction');
  return ee.Feature(null, {
    minLeafPopulation: ml,
    Accuracy: confusion.accuracy(),
    Kappa: confusion.kappa()
  });
});

var resultsLeafFC = ee.FeatureCollection(resultsLeaf);
//print('Tuning minLeafPopulation results:', resultsLeafFC);

// var chartLeaf = ui.Chart.feature.byFeature({
//   features: resultsLeafFC,
//   xProperty: 'minLeafPopulation',
//   yProperties: ['Accuracy', 'Kappa']
// }).setOptions({
//   title: 'RF Performance vs Min Leaf Population',
//   hAxis: {title: 'Min Leaf Population'},
//   vAxis: {title: 'Metric Value'},
//   colors: ['purple', 'red']
// });
// print(chartLeaf);

var bestLeaf = resultsLeafFC.sort('Accuracy', false).first().get('minLeafPopulation');
// print('Best minLeafPopulation:', bestLeaf);

// --------------------------------------
// Step 4: Tune bagFraction
// --------------------------------------
var bagList = ee.List.sequence(0.3, 1.0, 0.1); // 0.3 → 1.0 by 0.1

var resultsBag = bagList.map(function(bf) {
  bf = ee.Number(bf);
  
  var rf = ee.Classifier.smileRandomForest({
    numberOfTrees: bestTrees,
    variablesPerSplit: bestVars,
    minLeafPopulation: bestLeaf,
    bagFraction: bf
  })
  .setOutputMode('PROBABILITY')
  .train({
    features: trainingPoints,
    classProperty: species + ' Obs_Presence',
    inputProperties: seasonMetrics.bandNames()
  });
  
  var binaryPred = seasonMetrics.classify(rf)
    .gt(0.7)
    .rename(species + '_binary_prediction');
  
  var test = binaryPred.sampleRegions({
    collection: testingPoints,
    properties: [species + ' Obs_Presence'],
    scale: 30
  });
  
  var confusion = test.errorMatrix(species + ' Obs_Presence', species + '_binary_prediction');
  return ee.Feature(null, {
    bagFraction: bf,
    Accuracy: confusion.accuracy(),
    Kappa: confusion.kappa()
  });
});

var resultsBagFC = ee.FeatureCollection(resultsBag);
//print('Tuning bagFraction results:', resultsBagFC);

// var chartBag = ui.Chart.feature.byFeature({
//   features: resultsBagFC,
//   xProperty: 'bagFraction',
//   yProperties: ['Accuracy', 'Kappa']
// }).setOptions({
//   title: 'RF Performance vs Bag Fraction',
//   hAxis: {title: 'Bag Fraction'},
//   vAxis: {title: 'Metric Value'},
//   colors: ['teal', 'red']
// });
// print(chartBag);

var bestBag = resultsBagFC.sort('Accuracy', false).first().get('bagFraction');
// print('Best bagFraction:', bestBag);

// --------------------------------------
// Step 6: Tune probability threshold
// --------------------------------------
var thresholdList = ee.List.sequence(0.1, 1.0, 0.1);

// Pre-train the model once with the best parameters
var tunedRF = ee.Classifier.smileRandomForest({
  numberOfTrees: bestTrees,
  variablesPerSplit: bestVars,
  minLeafPopulation: bestLeaf,
  bagFraction: bestBag
})
.setOutputMode('PROBABILITY')
.train({
  features: trainingPoints,
  classProperty: species + ' Obs_Presence',
  inputProperties: seasonMetrics.bandNames()
});

// Predict probabilities once
var probImage = seasonMetrics.classify(tunedRF).rename(species + '_prob_final');

// Evaluate at different thresholds
var resultsThresh = thresholdList.map(function(th) {
  th = ee.Number(th);
  
  var binaryPred = probImage.gt(th).rename(species + '_binary_prediction');
  
  var test = binaryPred.sampleRegions({
    collection: testingPoints,
    properties: [species + ' Obs_Presence'],
    scale: 30
  });
  
  var confusion = test.errorMatrix(species + ' Obs_Presence', species + '_binary_prediction');
  var acc = confusion.accuracy();
  var kappa = confusion.kappa();
  
  return ee.Feature(null, {
    Threshold: th,
    Accuracy: acc,
    Kappa: kappa
  });
});

var resultsThreshFC = ee.FeatureCollection(resultsThresh);
//print('Tuning probability threshold results:', resultsThreshFC);

// Plot Accuracy & Kappa vs Threshold
// var chartThresh = ui.Chart.feature.byFeature({
//   features: resultsThreshFC,
//   xProperty: 'Threshold',
//   yProperties: ['Accuracy', 'Kappa']
// }).setOptions({
//   title: 'Model Performance vs Probability Threshold',
//   hAxis: {title: 'Threshold'},
//   vAxis: {title: 'Metric Value'},
//   colors: ['blue', 'red']
// });
// print(chartThresh);

// Get best threshold based on Accuracy
var bestThresh = resultsThreshFC.sort('Accuracy', false).first().get('Threshold');
//print('Best Threshold:', bestThresh);

// --------------------------------------
// Step 7: Apply final model and threshold
// --------------------------------------
var finalBinary = probImage.gt(0.7).rename(species + '_binary_final');

// Define pixel area (each 30 m pixel = 900 m²)
var pixelArea = ee.Image.pixelArea();

// Mask and count class 0 (absence)
var area0 = pixelArea.updateMask(finalBinary.select(species + '_binary_final').eq(0))
  .reduceRegion({
    reducer: ee.Reducer.sum(),
    geometry: geometry,
    scale: 30,
    maxPixels: 1e13,
    tileScale: 4
  }).get('area');

// Mask and count class 1 (presence)
var area1 = pixelArea.updateMask(finalBinary.select(species + '_binary_final').eq(1))
  .reduceRegion({
    reducer: ee.Reducer.sum(),
    geometry: geometry,
    scale: 30,
    maxPixels: 1e13,
    tileScale: 4
  }).get('area');

// Convert to pixel counts (divide by 900 m² per pixel)
var count0 = ee.Number(area0).divide(900);
var count1 = ee.Number(area1).divide(900);

//print('Pixel counts:', count0, count1);

var ratio = count0.divide(count1);
//print('Ratio (count0 : count1) =', ratio.format('%.2f'));

//print(testingPoints)

var totalPts = 33;  // your total number of test points

// ratio = count0 / count1  → so fraction of 0s = ratio / (1 + ratio)
var frac0 = ratio.divide(ratio.add(1));
var frac1 = ee.Number(1).divide(ratio.add(1));

// Compute proportional counts
var n0 = frac0.multiply(totalPts).round();
var n1 = frac1.multiply(totalPts).round();

//print('Target counts → absence (0):', n0, ' presence (1):', n1);

// Define the property name dynamically
var obsProp = species + ' Obs_Presence';

// Split your collection
var presPoints = testingPoints.filter(ee.Filter.eq(obsProp, 1));
var absPoints  = testingPoints.filter(ee.Filter.eq(obsProp, 0));

// Randomize and take subsets
presPoints = presPoints.randomColumn('rand').sort('rand').limit(n1);
absPoints  = absPoints.randomColumn('rand').sort('rand').limit(n0);

// Merge into a new proportional collection
var testingPoints_ratio = absPoints.merge(presPoints);

print('Number of points in final balanced set:', testingPoints_ratio.size());

var testFinal = finalBinary.sampleRegions({
  collection: testingPoints_ratio,
  properties: [species + ' Obs_Presence'],
  scale: 30
});

var finalConf = testFinal.errorMatrix(species + ' Obs_Presence', species + '_binary_final');
print(species + '=== FINAL OPTIMIZED MODEL RESULTS ===');
print('Confusion Matrix:', finalConf);
print('Overall Accuracy:', finalConf.accuracy());
print('Kappa:', finalConf.kappa());
print('Producers Accuracy:', finalConf.producersAccuracy());
print('Users Accuracy:', finalConf.consumersAccuracy());



// Add map layer
Map.addLayer(finalBinary,
  {min: 0, max: 1, palette: ['white', 'green']},
  species + ' Final Optimized Prediction');

// Define export parameters
Export.image.toDrive({
  image: finalBinary,  // the image you want to export
  description: species + '_FinalOptimizedPrediction', // export task name
  folder: 'GEE_Exports',  // optional: folder in your Google Drive
  fileNamePrefix: species + '_FinalOptimizedPrediction', 
  region: finalBinary.geometry(),  // the export region; adjust if needed
  scale: 30,  // resolution in meters; adjust to match your data
  maxPixels: 1e13  // to allow large exports
});


// // -----------------------
// // 3. Stage 2: Regression model (only where proportion > 0)
// // -----------------------

// // 1️⃣ Sample the probability raster at training points
var trainingWithPred = finalBinary.addBands(seasonMetrics).sampleRegions({
  collection: trainingPoints,
  scale: 30,
  geometries: true
});

//print(trainingWithPred)

// // 2️⃣ Filter to where oak presence was predicted (binary = 1)
var regPoints = trainingWithPred.filter(
  ee.Filter.eq(species + '_binary_final', 1)
);

//print(regPoints)



// --------------------------------------
// Step 1: Tune numberOfTrees
// --------------------------------------
var nTreeList = ee.List.sequence(50, 10000, 50);

var resultsRegTrees = nTreeList.map(function(nt) {
  nt = ee.Number(nt);

  var rf = ee.Classifier.smileRandomForest({
    numberOfTrees: nt,
    variablesPerSplit: 5,
    minLeafPopulation: 1,
    bagFraction: 0.9
  })
  .setOutputMode('REGRESSION')
  .train({
    features: regPoints,
    classProperty: species,
    inputProperties: seasonMetrics.bandNames()
  });


  var pred = seasonMetrics.classify(rf).rename(species +'_density_pred');
  
  
  var testingWithPred = finalBinary.addBands(pred).sampleRegions({
  collection: testingPoints,
  scale: 30,
  geometries: true
});


var testWithPred = testingWithPred.filter(
  ee.Filter.eq(species + '_binary_final', 1))
  
  
  
  var testSample = pred.sampleRegions({
    collection: testWithPred,
    properties: [species],
    scale: 30
  });

  var testEval = testSample.map(function(f) {
    var obs = ee.Number(f.get(species));
    var p = ee.Number(f.get(species +'_density_pred'));
    var diff = obs.subtract(p);
    return f.set('squared_error', diff.pow(2));
  });

  var mse = testEval.aggregate_mean('squared_error');
  var rmse = ee.Algorithms.If(mse, ee.Number(mse).sqrt(), ee.Number(0));
  return ee.Feature(null, {nTrees: nt, RMSE: rmse});
});

var resultsRegTreesFC = ee.FeatureCollection(resultsRegTrees);
//print('Regression tuning: nTrees', resultsRegTreesFC);

// var chartRegTrees = ui.Chart.feature.byFeature({
//   features: resultsRegTreesFC,
//   xProperty: 'nTrees',
//   yProperties: ['RMSE']
// }).setOptions({
//   title: 'RF Regression: RMSE vs Number of Trees',
//   hAxis: {title: 'Number of Trees'},
//   vAxis: {title: 'RMSE (lower = better)'},
//   colors: ['blue']
// });
// print(chartRegTrees);

var bestRegTrees = resultsRegTreesFC.sort('RMSE').first().get('nTrees');
//print('Best nTrees (Regression):', bestRegTrees);



// --------------------------------------
// Step 2: Tune variablesPerSplit
// --------------------------------------
var varSplitList = ee.List.sequence(1, 15, 1);  // adjust range if needed

var resultsRegVars = varSplitList.map(function(vs) {
  vs = ee.Number(vs);

  var rf = ee.Classifier.smileRandomForest({
    numberOfTrees: bestRegTrees,
    variablesPerSplit: vs,
    minLeafPopulation: 1,
    bagFraction: 0.9
  })
  .setOutputMode('REGRESSION')
  .train({
    features: regPoints,
    classProperty: species,
    inputProperties: seasonMetrics.bandNames()
  });

  var pred = seasonMetrics.classify(rf).rename(species +'_density_pred');

  var testingWithPred = finalBinary.addBands(pred).sampleRegions({
    collection: testingPoints,
    scale: 30,
    geometries: true
  });

  var testWithPred = testingWithPred.filter(
    ee.Filter.eq(species + '_binary_final', 1)
  );

  var testSample = pred.sampleRegions({
    collection: testWithPred,
    properties: [species],
    scale: 30
  });

  var testEval = testSample.map(function(f) {
    var obs = ee.Number(f.get(species));
    var p = ee.Number(f.get('Oak_density_pred'));
    var diff = obs.subtract(p);
    return f.set('squared_error', diff.pow(2));
  });

  var mse = testEval.aggregate_mean('squared_error');
  var rmse = ee.Algorithms.If(mse, ee.Number(mse).sqrt(), ee.Number(0));

  return ee.Feature(null, {
    variablesPerSplit: vs,
    RMSE: rmse
  });
});

var resultsRegVarsFC = ee.FeatureCollection(resultsRegVars);
//print('Regression tuning: variablesPerSplit', resultsRegVarsFC);

// var chartRegVars = ui.Chart.feature.byFeature({
//   features: resultsRegVarsFC,
//   xProperty: 'variablesPerSplit',
//   yProperties: ['RMSE']
// }).setOptions({
//   title: 'RF Regression: RMSE vs Variables per Split',
//   hAxis: {title: 'Variables per Split'},
//   vAxis: {title: 'RMSE (lower = better)'},
//   colors: ['red']
// });
// print(chartRegVars);

var bestRegVars = resultsRegVarsFC.sort('RMSE').first().get('variablesPerSplit');
//print('Best variablesPerSplit (Regression):', bestRegVars);


// --------------------------------------
// Step 3: Tune minLeafPopulation
// --------------------------------------
var minLeafList = ee.List.sequence(1, 10, 1);  // test from 1 to 10

var resultsRegLeaf = minLeafList.map(function(ml) {
  ml = ee.Number(ml);

  var rf = ee.Classifier.smileRandomForest({
    numberOfTrees: bestRegTrees,
    variablesPerSplit: bestRegVars,
    minLeafPopulation: ml,
    bagFraction: 0.9
  })
  .setOutputMode('REGRESSION')
  .train({
    features: regPoints,
    classProperty: species,
    inputProperties: seasonMetrics.bandNames()
  });

  var pred = seasonMetrics.classify(rf).rename('Oak_density_pred');

  var testingWithPred = finalBinary.addBands(pred).sampleRegions({
    collection: testingPoints,
    scale: 30,
    geometries: true
  });

  var testWithPred = testingWithPred.filter(
    ee.Filter.eq(species + '_binary_final', 1)
  );

  var testSample = pred.sampleRegions({
    collection: testWithPred,
    properties: [species],
    scale: 30
  });

  var testEval = testSample.map(function(f) {
    var obs = ee.Number(f.get(species));
    var p = ee.Number(f.get('Oak_density_pred'));
    var diff = obs.subtract(p);
    return f.set('squared_error', diff.pow(2));
  });

  var mse = testEval.aggregate_mean('squared_error');
  var rmse = ee.Algorithms.If(mse, ee.Number(mse).sqrt(), ee.Number(0));

  return ee.Feature(null, {
    minLeafPopulation: ml,
    RMSE: rmse
  });
});

var resultsRegLeafFC = ee.FeatureCollection(resultsRegLeaf);
//print('Regression tuning: minLeafPopulation', resultsRegLeafFC);

// var chartRegLeaf = ui.Chart.feature.byFeature({
//   features: resultsRegLeafFC,
//   xProperty: 'minLeafPopulation',
//   yProperties: ['RMSE']
// }).setOptions({
//   title: 'RF Regression: RMSE vs Min Leaf Population',
//   hAxis: {title: 'Min Leaf Population'},
//   vAxis: {title: 'RMSE (lower = better)'},
//   colors: ['orange']
// });
// print(chartRegLeaf);

var bestRegLeaf = resultsRegLeafFC.sort('RMSE').first().get('minLeafPopulation');
//print('Best minLeafPopulation (Regression):', bestRegLeaf);


// --------------------------------------
// Step 4: Tune bagFraction
// --------------------------------------
var bagList = ee.List.sequence(0.3, 1.0, 0.1);  // from 0.3 to 1.0 by 0.1

var resultsRegBag = bagList.map(function(bf) {
  bf = ee.Number(bf);

  var rf = ee.Classifier.smileRandomForest({
    numberOfTrees: bestRegTrees,
    variablesPerSplit: bestRegVars,
    minLeafPopulation: bestRegLeaf,
    bagFraction: bf
  })
  .setOutputMode('REGRESSION')
  .train({
    features: regPoints,
    classProperty: species,
    inputProperties: seasonMetrics.bandNames()
  });

  var pred = seasonMetrics.classify(rf).rename('Oak_density_pred');

  var testingWithPred = finalBinary.addBands(pred).sampleRegions({
    collection: testingPoints,
    scale: 30,
    geometries: true
  });

  var testWithPred = testingWithPred.filter(
    ee.Filter.eq(species + '_binary_final', 1)
  );

  var testSample = pred.sampleRegions({
    collection: testWithPred,
    properties: [species],
    scale: 30
  });

  var testEval = testSample.map(function(f) {
    var obs = ee.Number(f.get(species));
    var p = ee.Number(f.get('Oak_density_pred'));
    var diff = obs.subtract(p);
    return f.set('squared_error', diff.pow(2));
  });

  var mse = testEval.aggregate_mean('squared_error');
  var rmse = ee.Algorithms.If(mse, ee.Number(mse).sqrt(), ee.Number(0));

  return ee.Feature(null, {
    bagFraction: bf,
    RMSE: rmse
  });
});

var resultsRegBagFC = ee.FeatureCollection(resultsRegBag);
//print('Regression tuning: bagFraction', resultsRegBagFC);

// var chartRegBag = ui.Chart.feature.byFeature({
//   features: resultsRegBagFC,
//   xProperty: 'bagFraction',
//   yProperties: ['RMSE']
// }).setOptions({
//   title: 'RF Regression: RMSE vs Bag Fraction',
//   hAxis: {title: 'Bag Fraction'},
//   vAxis: {title: 'RMSE (lower = better)'},
//   colors: ['green']
// });
// print(chartRegBag);

var bestRegBag = resultsRegBagFC.sort('RMSE').first().get('bagFraction');
//print('Best bagFraction (Regression):', bestRegBag);


// --------------------------------------
// Step 5: Final optimized regression model
// --------------------------------------
var rfRegFinal = ee.Classifier.smileRandomForest({
  numberOfTrees: bestRegTrees,
  variablesPerSplit: bestRegVars,
  minLeafPopulation: bestRegLeaf,
  bagFraction: bestRegBag
})
.setOutputMode('REGRESSION')
.train({
  features: regPoints,
  classProperty: species,
  inputProperties: seasonMetrics.bandNames()
});

// Apply regression model (predicted oak density)
var oakDensityPredFinal = seasonMetrics.classify(rfRegFinal)
  .rename(species + '_density_pred_final');

// Mask to presence only
var oakDensityMaskedFinal = oakDensityPredFinal.updateMask(finalBinary);

// Visualize final predicted density
Map.addLayer(
  oakDensityMaskedFinal,
  {min: 0, max: 1, palette: ['lightyellow', 'darkgreen']},
  species + ' Final Predicted Density (Optimized)'
);

Export.image.toDrive({
  image: oakDensityMaskedFinal,
  description: species + '_Final_Predicted_Density_Optimized',
  folder: 'GEE_Exports', // Change this to your desired Drive folder name
  fileNamePrefix: species + '_Final_Predicted_Density_Optimized',
  region: oakDensityMaskedFinal.geometry(), // or use your study area geometry
  scale: 30, // adjust depending on your dataset’s resolution
  maxPixels: 1e13
});


// --------------------------------------
// Evaluate on testing data
// --------------------------------------
var testingWithPredFinal = finalBinary.addBands(oakDensityPredFinal).sampleRegions({
  collection: testingPoints,
  scale: 30,
  geometries: true
});

// Filter to where species is present
var testWithPredFinal = testingWithPredFinal.filter(
  ee.Filter.eq(species + '_binary_final', 1)
);

// Compute residuals and squared error
var testEvalFinal = testWithPredFinal.map(function(f) {
  var obs = ee.Number(f.get(species));
  var pred = ee.Number(f.get(species + '_density_pred_final'));
  var diff = obs.subtract(pred);
  return f.set({
    residual: diff,
    squared_error: diff.pow(2)
  });
});

// Compute RMSE
var mseFinal = testEvalFinal.aggregate_mean('squared_error');
var rmseFinal = ee.Algorithms.If(mseFinal, ee.Number(mseFinal).sqrt(), ee.Number(0));

print(species + '=== FINAL OPTIMIZED RF REGRESSION RESULTS ===');
//print('Best parameters:');
//print('  Trees:', bestRegTrees);
//print('  Vars per Split:', bestRegVars);
//print('  Min Leaf:', bestRegLeaf);
//print('  Bag Fraction:', bestRegBag);
print('Final RMSE:', rmseFinal);



//End of loop
 });


