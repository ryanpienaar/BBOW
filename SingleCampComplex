---
title: "Spread_Simulations"
author: "Ryan Pienaar"
date: "`r Sys.Date()`"
output: html_document
---

```{r}

library(terra)
library(leaflet)
library(tmap)
library(tidyverse)
library(gganimate)
library(raster)
library(shiny)
library(shinyjs)
library(khroma)
library(gganimate)
library(sf)
library(gifski)

```


```{r}

# input data
denspath <- "Z:/BBOW/Results/Maps/Regression/Oak_Density.tif" # Oak density map filepath
park <- vect("Y:/rpienaar/Apostle Islands/Map/Apostle_Islands_Map/Admin_Shapefiles/Apostle Islands National Lakeshore.shp") # APostle Islands Shapefile
camps <- read.csv("nps_boundary/Campsites.csv") # Apostle Islands campsites shapefile
dempath <- "Y:/rpienaar/Apostle Islands/Map/DEM_Apostle_Islands_30m.tif" # Path for dem raster
directions <- 8                      # Sets directions that will be test for wilt transition. This includes every neigboring cell

# Load raster
oakdens <- rast(denspath)
dem <- rast(dempath)

# select a campsite
camps_sub <- camps |> unite("Location", Island, Site.., sep = " - ", remove = FALSE) # creates a single field unique identifier

testcamp <- camps_sub |> filter(Location=="Oak - 2") # choose a site
campslist <- camps_sub |> filter(Island == "Oak") # choose all on Oak
start_pt <- vect(testcamp, geom = c("Longitude", "Latitude"), crs = crs(oakdens))

```

Interactive oak density map

```{r}

# Create color palette
pal <- colorNumeric(
  palette = rev(as.vector(colour("bamako")(100))),  # reverse color order
  domain  = values(oakdens),
  na.color = "transparent"
)

pal_colors <- rev(as.vector(colour("bamako")(100)))

# Create leaflet map
m <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%  # nicer basemap
  #addTiles() %>%
  addRasterImage(oakdens, colors = pal, opacity = 0.8) %>%
  addLegend(pal = pal, values = values(oakdens), title = "Predicted Oak Density") %>%
  addCircleMarkers(
    data = camps,
    lng = ~Longitude,
    lat = ~Latitude,
    radius = 2,
    color = "black",
    fillColor = "yellow",
    fillOpacity = 0.8,
    popup = ~paste("Campsite:", ifelse("Name" %in% names(camps), Name, "Unknown"))
  )

# Show map
m
```

Static oak density map

```{r}
# Create the static map for publication

camps <- camps |> filter(Island != "Outer")

camps_sf <- st_as_sf(
  camps,
  coords = c("Longitude", "Latitude"),
  crs = 4326   # WGS84
)

tmap_mode("plot")   # interactive mode, like leaflet

# If `oakdens` is a terra raster, convert to SpatRaster â†’ stars/sf-like object:
oakdens_r <- oakdens
class(oakdens_r)
# Create the map
oak_map <- tm_basemap("CartoDB.PositronNoLabels") +

  # Raster layer
  tm_shape(oakdens_r) +
  tm_raster(
    palette = pal_colors,
    title = "Predicted Oak Density"
  ) +

  # Campsite points
  tm_shape(camps_sf) +
  tm_symbols(
    shape = 21,
    col = "purple",
    size = 0.5,
    fill_alpha = 0.8,
    #popup = "Name"   # automatically uses the Name column
  ) +
   # Add legend entry for campsites
  tm_add_legend(
    type = "symbol",
    labels = "Campsites",
    col = "purple",
    shape = 21,
    size = 0.5
  ) +

  # Legend options (optional)
  tm_layout(
    legend.outside = FALSE,
  legend.position = c("right", "bottom"),
  legend.just = c("right", "bottom"),
  fontfamily = "serif"
  )

oak_map

tmap_save(
  tm = oak_map,             # saves the most recent tmap object
  filename = "Results/oak_density_map.png",
  width = 2000, height = 2000, # pixels (optional)
  dpi = 300                     # high resolution
)

```

Align raster

```{r}

# Align dem to the oakdens template
dem <- project(dem, crs(oakdens))
dem <- resample(dem, oakdens, method = "bilinear")

```

Rasterize soils shapefile to match oakdens grid

```{r}

soil_map <- st_read("Y:/rpienaar/Apostle Islands/Map/Soils/soil_map.shp")

# Rasterize soil shapefile to oakdens grid and assign multipliers
# - Fluvents  = 0.75
# - Psamments = 1
# - Udalfs    = 0.75
# - hemists   = 1
# - All others (and cells not covered by polygons) = 0.5


rasterize_soils_to_oakdens <- function(soils_shp,
                                       oakdens,
                                       class_col = NULL,
                                       mapping = NULL,
                                       default_other = 0,
                                       method = "near",        # rasterize numeric attribute -> 'near' is fine
                                       filename = "",
                                       overwrite = FALSE) {
  # Input checks
  if (!inherits(oakdens, "SpatRaster")) stop("oakdens must be a terra SpatRaster")
  if (is.character(soils_shp)) {
    if (!file.exists(soils_shp)) stop("soils_shp path does not exist: ", soils_shp)
    soils_sf <- st_read(soils_shp, quiet = TRUE)
  } else if (inherits(soils_shp, "sf")) {
    soils_sf <- soils_shp
  } else if (inherits(soils_shp, "SpatVector")) {
    soils_sf <- st_as_sf(soils_shp)
  } else {
    stop("soils_shp must be a path to a shapefile, an sf, or a SpatVector")
  }


  # Ensure soils and oakdens share CRS: transform soils to oakdens CRS if needed
  
  oak_crs <- crs(oakdens)
  if (is.na(st_crs(soils_sf))) {
    warning("Soils shapefile has no CRS. Assuming oakdens CRS.")
    st_crs(soils_sf) <- oak_crs
  } else {
    # compare WKT/PROJ strings; transform if different
    if (st_crs(soils_sf)$wkt != oak_crs) {
      soils_sf <- st_transform(soils_sf, crs = oak_crs)
    }
  }

  # Normalize soil class labels (lowercase, trimmed)
  soils_sf$.soil_label <- tolower(trimws(as.character(soils_sf[[class_col]])))

  # Default mapping if none supplied (keys must be lowercase)
  if (is.null(mapping)) {
    mapping <- c(
      "fluvents"  = 0.75,
      "psamments" = 1.0,
      "udalfs"    = 0.5,
      "hemists"   = 1.0,
      "aquolls" = 0.5,
      "udolls" = 0.5,
      "aquetpts" = 0.5,
      "sparists" = 0.5,
      "udepts" = 0.5,
      "aqalfs" = 0.5,
      "aquents" = 0.5,
      "orthods" = 0.5
    )
  } else {
    # normalize mapping names to lowercase
    names(mapping) <- tolower(names(mapping))
  }

  # Build numeric multiplier column: use mapping when matched, otherwise default_other
  soils_sf$.mult <- default_other
  # match and assign
  matched_idx <- match(soils_sf$.soil_label, names(mapping))
  has_match <- !is.na(matched_idx)
  if (any(has_match)) {
    soils_sf$.mult[has_match] <- as.numeric(mapping[matched_idx[has_match]])
  }

  # Convert to SpatVector for rasterize
  soils_v <- terra::vect(soils_sf)

  # Rasterize the numeric '.mult' field to oakdens geometry
  # Using touches = TRUE so polygons touching a cell count
  message("Rasterizing soils to oakdens grid (this will match extent/resolution/origin of oakdens)...")
  soil_mult_r <- terra::rasterize(soils_v, oakdens, field = ".mult", touches = TRUE,
                                  filename = filename, overwrite = overwrite)

  # For cells not covered by polygons (NA), set to default_other so "all others = 0.1"
  vals <- terra::values(soil_mult_r)
  if (any(is.na(vals))) {
    vals[is.na(vals)] <- default_other
    terra::values(soil_mult_r) <- vals
  }

  message("Rasterization complete. Returning SpatRaster aligned to oakdens.")
  return(soil_mult_r)
}

head(soil_map)
plot(soil_map["txsbrdr"], main = "Soil suborders (txsbrdr)")


# Example (uncomment and adapt paths/objects):
soils_shp <- "Y:/rpienaar/Apostle Islands/Map/Soils/soil_map.shp"
soil_raster <- rasterize_soils_to_oakdens(soils_shp, oakdens, class_col = "txsbrdr")
soil_masked <- mask(soil_raster, park)
plot(soil_masked, main = "Soil multiplier (aligned to oakdens)")

```

Plot map nicely

```{r}


slope  <- terrain(dem, v = "slope", unit = "radians")
aspect <- terrain(dem, v = "aspect", unit = "radians")
hill   <- shade(slope, aspect)

plot(hill, col = gray.colors(100), legend = FALSE,
     main = "Soil multiplier")

plot(soil_masked,
     add = TRUE,
     alpha = 0.6)

lines(park, lwd = 2)

```



Cropped starting point: Do this for just an island

```{r}

# islands <- vect("Y:/rpienaar/Apostle Islands/Map/APIS_Islands_Ind.shp")
# 
# 
# oak_island <- islands[grepl("Oak", islands$NAME, ignore.case = TRUE), ]
# 
# oak_island <- project(oak_island, crs(oakdens))
# 
# dem    <- crop(dem, oak_island)
# oakdens  <- crop(oakdens, oak_island)
# soil     <- crop(soil_raster, oak_island)
# 
# # get the starting cell (closest raster cell to campsite point)
# start_xy <- crds(start_pt)           # matrix of coordinates (1 row if single)
# start_cell <- cellFromXY(oakdens, start_xy)
# 
# # ensure NAs remain as NA
# names(oakdens) <- "density"
# 
# ncell_tot <- ncell(oakdens)
# cells_idx <- seq_len(ncell_tot)
# dens_vals <- values(oakdens)%>% replace(is.na(.), 0)
# 
# start_cell

```
Do this for the whole archipelago

```{r}

# get the starting cell (closest raster cell to campsite point)
start_xy <- crds(start_pt)           # matrix of coordinates (1 row if single)
start_cell <- cellFromXY(oakdens, start_xy) # Selects the cell in the raster with those coordinates

# ensure NAs remain as NA
names(oakdens) <- "density"

ncell_tot <- ncell(oakdens) # Number of valid cells in oakdens
cells_idx <- seq_len(ncell_tot) # Gives each cell an ID
dens_vals <- values(oakdens)%>% replace(is.na(.), 0)

start_cell

```


Create matrix of pixel pairs to estimate transmission
This out put is 2 column matrix that shows every pixel paired with every pixel it touches

```{r}

# --- Precompute adjacency pairs (both directions) ---
# adjacent(..., pairs=TRUE) returns unique neighbor pairs (i,j), likely i<j; we want directed transmission so duplicate both directions
adj_pairs <- adjacent(oakdens, cells = cells_idx, directions = directions, pairs = TRUE)
# ensure it's a matrix (terra returns two-column matrix)
adj_pairs <- as.matrix(adj_pairs)
# duplicate to get directed edges both ways
adj_pairs_dir <- rbind(adj_pairs, adj_pairs[, c(2,1)])
colnames(adj_pairs_dir) <- c("from", "to")

```


Crop my input rasters to only oak island

```{r}



tm_basemap("CartoDB.PositronNoLabels") +

  # Raster layer
  tm_shape(oakdens) +
  tm_raster(
    palette = pal_colors,
    title = "Predicted Oak Density"
  ) +

  # Oak island boundary
  # tm_shape(oak_island) +
  # tm_borders(
  #   col = "black",
  #   lwd = 2
  # ) +

  # Campsite points
  tm_shape(camps_sf) +
  tm_symbols(
    shape = 21,
    col = "purple",
    size = 0.5,
    fill_alpha = 0.8
  ) +

  # Legend entry for campsites
  tm_add_legend(
    type = "symbol",
    labels = "Campsites",
    col = "purple",
    shape = 21,
    size = 0.5
  ) +

  tm_layout(
    legend.outside = FALSE,
    legend.position = c("right", "top"),
    legend.just = c("right", "top"),
    fontfamily = "serif"
  )

```


Simulation function Base

```{r}

trans_fun_base <- function(oakdens, dens_vals, adj_pairs_dir, start_cell, max_steps = 100) {
  # checks
  if (missing(oakdens) || !inherits(oakdens, "SpatRaster")) stop("oakdens must be a SpatRaster")
  if (is.na(start_cell) || start_cell < 1 || start_cell > ncell(oakdens)) {
    stop("start_cell is NA or out of range")
  }
  if (length(dens_vals) != ncell(oakdens)) {
    stop("length(dens_vals) must equal number of cells in oakdens")
  }

  infected <- rep(0L, length(dens_vals)) # Set all cells to 0
  infected[start_cell] <- 1L # Set start cell to 1
  infected[is.na(dens_vals)] <- NA_integer_  # keeps NAs NA

  # store history: t0 initial state
  history <- list()
  r0 <- rast(oakdens)         # copy template
  values(r0) <- infected
  names(r0) <- "t0"
  history[[1]] <- r0

  # counters
  new_local_vec <- integer(0)
  new_jump_vec  <- integer(0)  # always 0 here
  cum_local <- 0L
  cum_jump  <- 0L

  step <- 1L
  while (step <= max_steps) {
    # indices of currently infected (non-NA)
    current_inf_idx <- which(infected == 1L)
    if (length(current_inf_idx) == 0) break

    local_new <- 0L
    # candidate directed adjacency rows: from infected -> to uninfected (and not NA)
    valid_to_mask <- (infected == 0L)
    rows_mask <- (infected[adj_pairs_dir[,1]] == 1L) & (valid_to_mask[adj_pairs_dir[,2]])
    if (!any(rows_mask, na.rm = TRUE)) {
      # nothing to spread this step
      new_local_vec <- c(new_local_vec, 0L)
      new_jump_vec  <- c(new_jump_vec, 0L)
      # save step raster
      rstep <- rast(oakdens); values(rstep) <- infected; names(rstep) <- paste0("t", step)
      history[[length(history) + 1]] <- rstep
      step <- step + 1L
      next
    }

    pairs_sub <- adj_pairs_dir[rows_mask, , drop = FALSE]
    from_idx <- pairs_sub[,1]
    to_idx <- pairs_sub[,2]

    # per-link infection probability p_kj = (density_from + density_to) / 2
    p_kj <- (dens_vals[from_idx] + dens_vals[to_idx]) / 2
    p_kj[is.na(p_kj)] <- 0
    p_kj[dens_vals[from_idx] == 0 | dens_vals[to_idx] == 0] <- 0

    p_kj <- pmin(pmax(p_kj, 0), 1)

    one_minus_p <- 1 - p_kj
    prod_1_minus_p_by_to <- tapply(one_minus_p, INDEX = to_idx, FUN = prod)
    to_cells_unique <- as.integer(names(prod_1_minus_p_by_to))
    p_total_by_to <- 1 - as.numeric(prod_1_minus_p_by_to)

    draws <- runif(length(to_cells_unique))
    newly_infected_idx <- to_cells_unique[draws < p_total_by_to]

    if (length(newly_infected_idx) > 0) {
      infected[newly_infected_idx] <- 1L
      local_new <- as.integer(length(newly_infected_idx))
      cum_local <- cum_local + local_new
    }

    # record counts for this step
    new_local_vec <- c(new_local_vec, local_new)
    new_jump_vec  <- c(new_jump_vec, 0L)

    # save step raster
    rstep <- rast(oakdens); values(rstep) <- infected; names(rstep) <- paste0("t", step)
    history[[length(history) + 1]] <- rstep

    step <- step + 1L
  }

  final_r <- rast(oakdens)
  values(final_r) <- infected
  names(final_r) <- "final"

  # Build counts dataframe
  nsteps_recorded <- length(new_local_vec)
  steps <- seq_len(nsteps_recorded)
  cum_local_vec <- cumsum(new_local_vec)
  cum_jump_vec  <- cumsum(new_jump_vec)
  counts_df <- data.frame(
    step = steps,
    new_local = new_local_vec,
    new_jump = new_jump_vec,
    new_total = new_local_vec + new_jump_vec,
    cum_local = cum_local_vec,
    cum_jump = cum_jump_vec,
    cum_total = cum_local_vec + cum_jump_vec
  )

  return(list(history = history, final = final_r, counts = counts_df))
}

sim1 <- trans_fun_base(oakdens = oakdens,
                       dens_vals = dens_vals,
                       adj_pairs_dir = adj_pairs_dir,
                       start_cell = start_cell,
                       max_steps = 20)

```

Add slope

```{r}


# Updated simulation: multiplies transmission probability by soil multiplier raster/value
#
# Usage:
# sim1 <- run_single_sim(
#   oakdens = oakdens,
#   dem = dem_aligned,
#   dens_vals = dens_vals,
#   soil_mult = soil_mult_r,          # SpatRaster OR numeric vector aligned to oakdens
#   adj_pairs_dir = adj_pairs_dir,
#   start_cell = start_cell,
#   max_steps = 100,
#   beta = 0.1,
#   soil_effect = "to"                # "to" (default), "from", or "both"
# )
#
# trans_fun_slope with per-step counts (local only; includes elevation multiplier)
trans_fun_slope <- function(oakdens,
                            dens_vals,
                            dem,
                            soil_mult = NULL,
                            adj_pairs_dir,
                            start_cell,
                            max_steps = 100,
                            beta = 0.1,
                            slope_fun = NULL,
                            soil_effect = c("to", "from", "both")) {
  soil_effect <- match.arg(soil_effect)

  # basic checks
  if (!inherits(oakdens, "SpatRaster")) stop("oakdens must be a SpatRaster")
  if (!inherits(dem, "SpatRaster")) stop("dem must be a SpatRaster")
  if (ncell(oakdens) != ncell(dem)) stop("oakdens and dem must have the same number of cells and alignment")
  if (length(dens_vals) != ncell(oakdens)) stop("length(dens_vals) must equal number of cells in oakdens")
  if (is.na(start_cell) || start_cell < 1 || start_cell > ncell(oakdens)) stop("start_cell is NA or out of range")
  if (is.null(slope_fun)) slope_fun <- function(abs_diff) exp(-beta * abs_diff)

  # prepare soil multiplier as numeric vector aligned to oakdens cells (if provided)
  if (is.null(soil_mult)) {
    soil_vec <- rep(1, ncell(oakdens))
  } else if (inherits(soil_mult, "SpatRaster")) {
    if (!compareGeom(soil_mult, oakdens, stopOnError = FALSE)) {
      message("Soil raster geometry differs from oakdens; resampling soil raster to oakdens grid (method = 'near')...")
      soil_mult <- resample(soil_mult, oakdens, method = "near")
    }
    soil_vec <- values(soil_mult)
  } else if (is.numeric(soil_mult) && length(soil_mult) == ncell(oakdens)) {
    soil_vec <- soil_mult
  } else {
    stop("soil_mult must be NULL, a SpatRaster, or a numeric vector of length ncell(oakdens)")
  }
  soil_vec[is.na(soil_vec)] <- 1

  dem_vals <- values(dem)

  # initialize infection vector
  infected <- rep(0L, length(dens_vals))
  infected[start_cell] <- 1L
  infected[is.na(dens_vals)] <- NA_integer_
  infected[is.na(dem_vals)] <- NA_integer_
  infected[is.na(soil_vec)] <- NA_integer_

  # history store
  history <- list()
  r0 <- rast(oakdens)
  values(r0) <- infected
  names(r0) <- "t0"
  history[[1]] <- r0

  # counters
  new_local_vec <- integer(0)
  new_jump_vec  <- integer(0) # no jump here
  cum_local <- 0L
  cum_jump  <- 0L

  step <- 1L
  while (step <= max_steps) {
    current_inf_idx <- which(infected == 1L)
    if (length(current_inf_idx) == 0) break

    local_new <- 0L

    # candidates: from infected -> to uninfected
    valid_to_mask <- (infected == 0L)
    rows_mask <- (infected[adj_pairs_dir[,1]] == 1L) & (valid_to_mask[adj_pairs_dir[,2]])
    if (!any(rows_mask, na.rm = TRUE)) {
      new_local_vec <- c(new_local_vec, 0L); new_jump_vec <- c(new_jump_vec, 0L)
      rstep <- rast(oakdens); values(rstep) <- infected; names(rstep) <- paste0("t", step)
      history[[length(history) + 1]] <- rstep
      step <- step + 1L
      next
    }

    pairs_sub <- adj_pairs_dir[rows_mask, , drop = FALSE]
    from_idx <- pairs_sub[,1]
    to_idx   <- pairs_sub[,2]

    # density component
    p_density <- (dens_vals[from_idx] + dens_vals[to_idx]) / 2
    p_density[is.na(p_density)] <- 0
    p_density[dens_vals[from_idx] == 0 | dens_vals[to_idx] == 0] <- 0

    # elevation multiplier
    abs_diff <- abs(dem_vals[from_idx] - dem_vals[to_idx])
    abs_diff_is_na <- is.na(abs_diff)
    abs_diff[abs_diff_is_na] <- 0
    slope_mult <- slope_fun(abs_diff)
    slope_mult[abs_diff_is_na] <- 0

    # soil multiplier optionally (kept for compatibility)
    if (soil_effect == "to") {
      s_mult <- soil_vec[to_idx]
    } else if (soil_effect == "from") {
      s_mult <- soil_vec[from_idx]
    } else {
      s_mult <- (soil_vec[from_idx] + soil_vec[to_idx]) / 2
    }
    s_mult[is.na(s_mult)] <- 1

    # combine all effects
    p_kj <- p_density * slope_mult * s_mult
    p_kj[is.na(p_kj)] <- 0
    p_kj <- pmin(pmax(p_kj, 0), 1)

    # aggregate incoming probabilities per 'to' cell
    one_minus_p <- 1 - p_kj
    prod_1_minus_p_by_to <- tapply(one_minus_p, INDEX = to_idx, FUN = prod)
    to_cells_unique <- as.integer(names(prod_1_minus_p_by_to))
    p_total_by_to <- 1 - as.numeric(prod_1_minus_p_by_to)

    draws <- runif(length(to_cells_unique))
    newly_infected_idx <- to_cells_unique[draws < p_total_by_to]

    if (length(newly_infected_idx) > 0) {
      infected[newly_infected_idx] <- 1L
      local_new <- as.integer(length(newly_infected_idx))
      cum_local <- cum_local + local_new
    }

    new_local_vec <- c(new_local_vec, local_new)
    new_jump_vec  <- c(new_jump_vec, 0L)

    # save raster
    rstep <- rast(oakdens); values(rstep) <- infected; names(rstep) <- paste0("t", step)
    history[[length(history) + 1]] <- rstep

    step <- step + 1L
  }

  final_r <- rast(oakdens)
  values(final_r) <- infected
  names(final_r) <- "final"

  # Build counts dataframe
  nsteps_recorded <- length(new_local_vec)
  steps <- seq_len(nsteps_recorded)
  cum_local_vec <- cumsum(new_local_vec)
  cum_jump_vec  <- cumsum(new_jump_vec)
  counts_df <- data.frame(
    step = steps,
    new_local = new_local_vec,
    new_jump = new_jump_vec,
    new_total = new_local_vec + new_jump_vec,
    cum_local = cum_local_vec,
    cum_jump = cum_jump_vec,
    cum_total = cum_local_vec + cum_jump_vec
  )

  return(list(history = history, final = final_r, counts = counts_df))
}

sim2 <- trans_fun_slope(oakdens = oakdens,
                       dem = dem,
                       dens_vals = dens_vals,
                       adj_pairs_dir = adj_pairs_dir,
                       start_cell = start_cell,
                       max_steps = 20,
                       soil_effect = "from",
                       soil_mult = soil_raster)



```

Add soils

```{r}

# Updated simulation: multiplies transmission probability by soil multiplier raster/value
#
# Usage:
# sim1 <- run_single_sim(
#   oakdens = oakdens,
#   dem = dem_aligned,
#   dens_vals = dens_vals,
#   soil_mult = soil_mult_r,          # SpatRaster OR numeric vector aligned to oakdens
#   adj_pairs_dir = adj_pairs_dir,
#   start_cell = start_cell,
#   max_steps = 100,
#   beta = 0.1,
#   soil_effect = "to"                # "to" (default), "from", or "both"
# )
#

# trans_fun_ss (soil + slope) with per-step counts
trans_fun_ss <- function(oakdens,
                         dens_vals,
                         dem,
                         soil_mult = NULL,
                         adj_pairs_dir,
                         start_cell,
                         max_steps = 100,
                         beta = 0.1,
                         slope_fun = NULL,
                         soil_effect = c("to", "from", "both")) {
  soil_effect <- match.arg(soil_effect)

  # basic checks
  if (!inherits(oakdens, "SpatRaster")) stop("oakdens must be a SpatRaster")
  if (!inherits(dem, "SpatRaster")) stop("dem must be a SpatRaster")
  if (ncell(oakdens) != ncell(dem)) stop("oakdens and dem must have the same number of cells and alignment")
  if (length(dens_vals) != ncell(oakdens)) stop("length(dens_vals) must equal number of cells in oakdens")
  if (is.na(start_cell) || start_cell < 1 || start_cell > ncell(oakdens)) stop("start_cell is NA or out of range")
  if (is.null(slope_fun)) slope_fun <- function(abs_diff) exp(-beta * abs_diff)

  # prepare soil multiplier as numeric vector aligned to oakdens cells
  if (is.null(soil_mult)) {
    soil_vec <- rep(1, ncell(oakdens))
  } else if (inherits(soil_mult, "SpatRaster")) {
    if (!compareGeom(soil_mult, oakdens, stopOnError = FALSE)) {
      message("Soil raster geometry differs from oakdens; resampling soil raster to oakdens grid (method = 'near')...")
      soil_mult <- resample(soil_mult, oakdens, method = "near")
    }
    soil_vec <- values(soil_mult)
  } else if (is.numeric(soil_mult) && length(soil_mult) == ncell(oakdens)) {
    soil_vec <- soil_mult
  } else {
    stop("soil_mult must be NULL, a SpatRaster, or a numeric vector of length ncell(oakdens)")
  }

  soil_vec[is.na(soil_vec)] <- 1

  dem_vals <- values(dem)

  # initialize infection vector
  infected <- rep(0L, length(dens_vals))
  infected[start_cell] <- 1L
  infected[is.na(dens_vals)] <- NA_integer_
  infected[is.na(dem_vals)] <- NA_integer_
  infected[is.na(soil_vec)] <- NA_integer_

  # history store
  history <- list()
  r0 <- rast(oakdens)
  values(r0) <- infected
  names(r0) <- "t0"
  history[[1]] <- r0

  # counters
  new_local_vec <- integer(0)
  new_jump_vec  <- integer(0) # no jump here
  cum_local <- 0L
  cum_jump  <- 0L

  step <- 1L
  while (step <= max_steps) {
    current_inf_idx <- which(infected == 1L)
    if (length(current_inf_idx) == 0) break

    local_new <- 0L

    # candidates: from infected -> to uninfected
    valid_to_mask <- (infected == 0L)
    rows_mask <- (infected[adj_pairs_dir[,1]] == 1L) & (valid_to_mask[adj_pairs_dir[,2]])
    if (!any(rows_mask, na.rm = TRUE)) {
      new_local_vec <- c(new_local_vec, 0L); new_jump_vec <- c(new_jump_vec, 0L)
      rstep <- rast(oakdens); values(rstep) <- infected; names(rstep) <- paste0("t", step)
      history[[length(history) + 1]] <- rstep
      step <- step + 1L
      next
    }

    pairs_sub <- adj_pairs_dir[rows_mask, , drop = FALSE]
    from_idx <- pairs_sub[,1]
    to_idx   <- pairs_sub[,2]

    # density component
    p_density <- (dens_vals[from_idx] + dens_vals[to_idx]) / 2
    p_density[is.na(p_density)] <- 0
    p_density[dens_vals[from_idx] == 0 | dens_vals[to_idx] == 0] <- 0

    # elevation multiplier
    abs_diff <- abs(dem_vals[from_idx] - dem_vals[to_idx])
    abs_diff_is_na <- is.na(abs_diff)
    abs_diff[abs_diff_is_na] <- 0
    slope_mult <- slope_fun(abs_diff)
    slope_mult[abs_diff_is_na] <- 0

    # soil multiplier depending on choice ("to","from","both")
    if (soil_effect == "to") {
      s_mult <- soil_vec[to_idx]
    } else if (soil_effect == "from") {
      s_mult <- soil_vec[from_idx]
    } else { # both: average of source and target multipliers
      s_mult <- (soil_vec[from_idx] + soil_vec[to_idx]) / 2
    }
    s_mult[is.na(s_mult)] <- 1

    # combine all effects: density * slope * soil
    p_kj <- p_density * slope_mult * s_mult

    # guard to [0,1]
    p_kj[is.na(p_kj)] <- 0
    p_kj <- pmin(pmax(p_kj, 0), 1)

    # aggregate incoming probabilities per 'to' cell
    one_minus_p <- 1 - p_kj
    prod_1_minus_p_by_to <- tapply(one_minus_p, INDEX = to_idx, FUN = prod)
    to_cells_unique <- as.integer(names(prod_1_minus_p_by_to))
    p_total_by_to <- 1 - as.numeric(prod_1_minus_p_by_to)

    # stochastic draws
    draws <- runif(length(to_cells_unique))
    newly_infected_idx <- to_cells_unique[draws < p_total_by_to]

    if (length(newly_infected_idx) > 0) {
      infected[newly_infected_idx] <- 1L
      local_new <- as.integer(length(newly_infected_idx))
      cum_local <- cum_local + local_new
    }

    new_local_vec <- c(new_local_vec, local_new)
    new_jump_vec  <- c(new_jump_vec, 0L)

    # store raster for this step
    rstep <- rast(oakdens)
    values(rstep) <- infected
    names(rstep) <- paste0("t", step)
    history[[length(history) + 1]] <- rstep

    step <- step + 1L
  }

  final_r <- rast(oakdens)
  values(final_r) <- infected
  names(final_r) <- "final"

  # Build counts dataframe
  nsteps_recorded <- length(new_local_vec)
  steps <- seq_len(nsteps_recorded)
  cum_local_vec <- cumsum(new_local_vec)
  cum_jump_vec  <- cumsum(new_jump_vec)
  counts_df <- data.frame(
    step = steps,
    new_local = new_local_vec,
    new_jump = new_jump_vec,
    new_total = new_local_vec + new_jump_vec,
    cum_local = cum_local_vec,
    cum_jump = cum_jump_vec,
    cum_total = cum_local_vec + cum_jump_vec
  )

  return(list(history = history, final = final_r, counts = counts_df))
}



sim3 <- trans_fun_ss(oakdens = oakdens,
                       dem = dem,
                       dens_vals = dens_vals,
                       adj_pairs_dir = adj_pairs_dir,
                       start_cell = start_cell,
                       max_steps = 20,
                       soil_effect = "from",
                       soil_mult = soil_raster)



```


Add a random insect vector function
```{r}


# run_single_sim with per-step and cumulative breakdown of local (ground) vs jump infections
# Returns: list(history, final, counts)
# counts columns: step, new_local, new_jump, new_total, cum_local, cum_jump, cum_total
library(terra)

trans_fun_full <- function(oakdens,
                           dens_vals,
                           dem,                # SpatRaster DEM aligned with oakdens
                           soil_mult = NULL,   # SpatRaster or numeric vector aligned to oakdens
                           adj_pairs_dir,
                           start_cell,
                           max_steps = 20,
                           beta = 0.1,
                           slope_fun = NULL,
                           soil_effect = c("to", "from", "both"),
                           # jump params
                           jump_enabled = TRUE,
                           jump_radius = 600,
                           jump_beta = 0.01,
                           # new density effect param
                           density_power = 1.0,
                           # verbosity: print per-step summaries
                           verbose = TRUE
) {
  soil_effect <- match.arg(soil_effect)
  if (!inherits(oakdens, "SpatRaster")) stop("oakdens must be a SpatRaster")
  if (!inherits(dem, "SpatRaster")) stop("dem must be a SpatRaster")
  if (ncell(oakdens) != ncell(dem)) stop("oakdens and dem must have same number of cells/alignment")
  if (length(dens_vals) != ncell(oakdens)) stop("length(dens_vals) must equal ncell(oakdens)")
  if (is.na(start_cell) || start_cell < 1 || start_cell > ncell(oakdens)) stop("start_cell invalid")
  if (is.null(slope_fun)) slope_fun <- function(abs_diff) exp(-beta * abs_diff)

  # prepare soil multiplier vector
  if (is.null(soil_mult)) {
    soil_vec <- rep(1, ncell(oakdens))
  } else if (inherits(soil_mult, "SpatRaster")) {
    if (!compareGeom(soil_mult, oakdens, stopOnError = FALSE)) {
      message("Resampling soil raster to oakdens grid (near)...")
      soil_mult <- resample(soil_mult, oakdens, method = "near")
    }
    soil_vec <- values(soil_mult)
  } else if (is.numeric(soil_mult) && length(soil_mult) == ncell(oakdens)) {
    soil_vec <- soil_mult
  } else stop("soil_mult must be NULL, a SpatRaster, or numeric vector matching oakdens cells")
  soil_vec[is.na(soil_vec)] <- 1

  dem_vals <- values(dem)

  # init infection vector
  infected <- rep(0L, length(dens_vals))
  infected[start_cell] <- 1L
  infected[is.na(dens_vals)] <- NA_integer_
  infected[is.na(dem_vals)] <- NA_integer_
  infected[is.na(soil_vec)] <- NA_integer_

  # history
  history <- list()
  r0 <- rast(oakdens); values(r0) <- infected; names(r0) <- "t0"; history[[1]] <- r0

  # counters: per-step and cumulative for local (ground) and jump
  new_local_vec <- integer(0)
  new_jump_vec  <- integer(0)
  cum_local     <- 0L   # count of infections attributed to local spread (excl. initial seed)
  cum_jump      <- 0L   # count of infections attributed to jump events
  # Treat initial seed as ground-introduced? If you prefer otherwise, change below:
  # We'll NOT count the initial seed in cum_local/cum_jump; counts start from spread events.
  # If you want to include the seed as local, set cum_local <- 1L here.

  step <- 1L
  while (step <= max_steps) {
    current_inf_idx <- which(infected == 1L)
    if (length(current_inf_idx) == 0) break

    local_new <- 0L
    jump_new  <- 0L

    # --------------------
    # Local neighbourhood spread
    # --------------------
    valid_to_mask <- (infected == 0L)
    rows_mask <- (infected[adj_pairs_dir[,1]] == 1L) & (valid_to_mask[adj_pairs_dir[,2]])
    if (any(rows_mask, na.rm = TRUE)) {
      pairs_sub <- adj_pairs_dir[rows_mask, , drop = FALSE]
      from_idx <- pairs_sub[,1]; to_idx <- pairs_sub[,2]

      # Restrict to targets with oak density > 0 (otherwise skip)
      keep_mask <- (dens_vals[to_idx] > 0)
      if (any(keep_mask, na.rm = TRUE)) {
        from_idx2 <- from_idx[keep_mask]
        to_idx2   <- to_idx[keep_mask]

        # density component (average)
        p_density <- (dens_vals[from_idx2] + dens_vals[to_idx2]) / 2
        p_density[is.na(p_density)] <- 0

        # apply additional density dependence using target density
        if (!is.null(density_power) && density_power != 0) {
          tp <- dens_vals[to_idx2]
          tp[is.na(tp)] <- 0
          p_density <- p_density * (tp ^ density_power)
        }

        # elevation multiplier
        abs_diff <- abs(dem_vals[from_idx2] - dem_vals[to_idx2])
        abs_diff_is_na <- is.na(abs_diff)
        abs_diff[abs_diff_is_na] <- 0
        slope_mult <- slope_fun(abs_diff)
        slope_mult[abs_diff_is_na] <- 0

        # soil multiplier acc. to choice
        if (soil_effect == "to") {
          s_mult <- soil_vec[to_idx2]
        } else if (soil_effect == "from") {
          s_mult <- soil_vec[from_idx2]
        } else {
          s_mult <- (soil_vec[from_idx2] + soil_vec[to_idx2]) / 2
        }
        s_mult[is.na(s_mult)] <- 1

        # combine
        p_kj <- p_density * slope_mult * s_mult
        p_kj[is.na(p_kj)] <- 0
        p_kj <- pmin(pmax(p_kj, 0), 1)

        # aggregate incoming probabilities
        one_minus_p <- 1 - p_kj
        prod_1_minus_p_by_to <- tapply(one_minus_p, INDEX = to_idx2, FUN = prod)
        to_cells_unique <- as.integer(names(prod_1_minus_p_by_to))
        p_total_by_to <- 1 - as.numeric(prod_1_minus_p_by_to)

        # stochastic draws
        if (length(p_total_by_to) > 0) {
          draws <- runif(length(to_cells_unique))
          newly_infected_idx <- to_cells_unique[draws < p_total_by_to]
          if (length(newly_infected_idx) > 0) {
            infected[newly_infected_idx] <- 1L
            local_new <- as.integer(length(newly_infected_idx))
            cum_local <- cum_local + local_new
          }
        }
      }
    }

    jump_counts <- c(0L, 1L, 2L, 5L)
    jump_probs  <- c(0.50, 0.25, 0.125, 0.125)

    n_jumps <- sample(jump_counts, size = 1, prob = jump_probs)
    # --------------------
    # Jump infection (one per timestep)
    # restrict jump candidates to cells with dens_vals > 0 and weight by density
    # --------------------
   jump_new <- 0L

if (jump_enabled && n_jumps > 0 && any(infected == 1L)) {

  for (j in seq_len(n_jumps)) {

    # source raster: currently infected cells
    src_r <- rast(oakdens)
    vals_src <- rep(NA_real_, ncell(oakdens))
    vals_src[infected == 1L] <- 1
    values(src_r) <- vals_src

    # distance to nearest infected
    dist_r <- distance(src_r)
    dist_vals <- values(dist_r)

    # candidate targets
    cand_idx <- which(
      infected == 0L &
      !is.na(dist_vals) &
      dist_vals <= jump_radius &
      dens_vals > 0
    )

    if (length(cand_idx) == 0) break

    # weights
    d_cand <- dist_vals[cand_idx]
    w_dist <- exp(-jump_beta * d_cand)

    if (!is.null(density_power) && density_power != 0) {
      w_dens <- dens_vals[cand_idx] ^ density_power
    } else {
      w_dens <- rep(1, length(cand_idx))
    }

    w <- w_dist * w_dens
    w[is.na(w) | w < 0] <- 0

    if (sum(w) == 0) break

    # draw jump target
    sel <- sample(cand_idx, size = 1, prob = w)

    infected[sel] <- 1L
    jump_new  <- jump_new + 1L
    cum_jump  <- cum_jump + 1L
  }
}

    # total new this step
    new_total <- local_new + jump_new
    cum_total <- cum_local + cum_jump
    # store per-step numbers
    new_local_vec <- c(new_local_vec, local_new)
    new_jump_vec  <- c(new_jump_vec, jump_new)

    # verbose message
    if (verbose) {
      message(sprintf("Step %d: new_total=%d (local=%d, jump=%d) | cum_local=%d, cum_jump=%d, cum_total=%d",
                      step, new_total, local_new, jump_new, cum_local, cum_jump, cum_total))
    }

    # save step raster
    rstep <- rast(oakdens); values(rstep) <- infected; names(rstep) <- paste0("t", step)
    history[[length(history) + 1]] <- rstep

    step <- step + 1L
  }

  final_r <- rast(oakdens); values(final_r) <- infected; names(final_r) <- "final"

  # Build counts dataframe
  nsteps_recorded <- length(new_local_vec)
  steps <- seq_len(nsteps_recorded)
  cum_local_vec <- cumsum(new_local_vec)
  cum_jump_vec  <- cumsum(new_jump_vec)
  counts_df <- data.frame(
    step = steps,
    new_local = new_local_vec,
    new_jump = new_jump_vec,
    new_total = new_local_vec + new_jump_vec,
    cum_local = cum_local_vec,
    cum_jump = cum_jump_vec,
    cum_total = cum_local_vec + cum_jump_vec
  )

  return(list(history = history, final = final_r, counts = counts_df))
}

sim4 <- trans_fun_full(
  oakdens = oakdens,
  dem = dem,
  dens_vals = dens_vals,
  soil_mult = soil_raster,       # SpatRaster or vector
  adj_pairs_dir = adj_pairs_dir,
  start_cell = start_cell,
  max_steps = 20,
  beta = log(2) / 50,           # elevation effect
  jump_enabled = TRUE,
  jump_radius = 600,             # metres (map units)
  jump_beta = 0.005,       # half-weight at 200 m (example)
  verbose = TRUE,
  density_power = 1.5
)

```


Plot the infection simulation

```{r}



# Convert to sf
camps_sf <- st_as_sf(
  camps,
  coords = c("Longitude", "Latitude"),
  crs = 4326   # WGS84
)

# Reproject to oakdens CRS so tmap layers align
oak_crs <- crs(oakdens)            # terra::crs returns proj4/WKT string acceptable to sf
if (is.na(oak_crs) || oak_crs == "") {
  warning("oakdens has no CRS. Points kept in their original CRS.")
} else {
  camps_sf <- st_transform(camps_sf, crs = oak_crs)
}

# Now build the map (uses your style; adjust palette etc. as desired)
# ensure pal_colors exists
if (!exists("pal_colors")) pal_colors <- rev(terrain.colors(7))

# Prepare infection layer (from sim1$final)
inf_r <- sim1$final
vals <- values(inf_r)
vals[!is.na(vals) & vals == 0] <- NA
values(inf_r) <- vals

oak_map <- tm_basemap("CartoDB.PositronNoLabels") +

  tm_shape(oakdens) +
  tm_raster(
    palette = pal_colors,
    title = "Predicted Oak Density"
  ) +

  tm_shape(inf_r) +
  tm_raster(
    palette = "Reds",
    title = "Infected (final)",
    alpha = 0.6,
    style = "cat"
  ) +

  tm_shape(camps_sf) +
  tm_symbols(
    shape = 21,
    col = "purple",
    size = 0.5,
    fill.alpha = 0.8
  ) +

  tm_add_legend(
    type = "symbol",
    labels = "Campsites",
    col = "purple",
    shape = 21,
    size = 0.5
  ) +

  tm_layout(
    legend.outside = FALSE,
    legend.position = c("right", "bottom"),
    legend.just = c("right", "bottom"),
    fontfamily = "serif"
  )

tmap_mode("plot")
oak_map

```

```{r}



# prepare infection raster (sim1$final from run_single_sim)
inf_r <- sim1$final

# set uninfected (0) -> NA so they are transparent on the overlay
inf_vals <- values(inf_r)
inf_vals[!is.na(inf_vals) & inf_vals == 0] <- NA
values(inf_r) <- inf_vals




## ---- Project rasters to Leaflet CRS (EPSG:3857) ----
oakdens_3857 <- project(oakdens, "EPSG:3857")
inf_3857     <- project(inf_r, "EPSG:3857")

## ---- Prepare infection raster: 1 = infected, NA = transparent ----
inf_vals <- values(inf_3857)
inf_vals[inf_vals == 0] <- NA
values(inf_3857) <- inf_vals

## ---- Convert to RasterLayer for leaflet ----
oakdens_r <- raster(oakdens_3857)
inf_r     <- raster(inf_3857)

## ---- Color palettes ----
pal_oak <- colorNumeric(
  palette = pal,
  domain  = range(0:1),
  na.color = "transparent"
)

pal_inf <- colorFactor(
  palette = "red",
  levels = 1,
  na.color = "transparent"
)

## ---- Count infected cells for legend ----
infected_count <- sum(values(inf_r) == 1, na.rm = TRUE)

## ---- Build Leaflet map ----
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%

  addRasterImage(
    oakdens_r,
    colors = pal_oak,
    opacity = 0.8,
    group = "Predicted Oak Density"
  ) %>%

  addLegend(
    pal = pal_oak,
    values = range(values(oakdens_r), na.rm = TRUE),
    title = "Predicted Oak Density",
    position = "topright"
  ) %>%

  addRasterImage(
    inf_r,
    colors = pal_inf,
    opacity = 0.6,
    group = "Oak Wilt"
  ) %>%

  addLegend(
    colors = "red",
    labels = paste0("Infected (", infected_count, ")"),
    title = "Oak Wilt",
    position = "bottomleft"
  ) %>%

 addCircleMarkers( data = camps,
    lng = ~Longitude,
    lat = ~Latitude,
    radius = 2,
    color = "black",
    fillColor = "yellow",
    fillOpacity = 0.8, popup = ~if ("Name" %in% names(camps)) paste("Campsite:", Name) else "Campsite" )%>%

  addLayersControl(
    overlayGroups = c(
      "Oak Wilt (t0)",
      "Predicted Oak Density",
      "Campsites"
    ),
    options = layersControlOptions(collapsed = FALSE)
  )
   

hist_stack <- rast(sim1$history)


```


Plot the time series

```{r}

# compute infected counts from sim1$history (list of SpatRasters t0, t1, ...)
counts <- sapply(sim1$history, function(r) {
  v <- values(r)
  sum(v == 1, na.rm = TRUE)   # ignore NA cells
})

years <- 0:(length(counts) - 1)   # year 0 = initial state, year 1 = after 1 timestep, etc.

library(ggplot2)

df <- data.frame(
  year = years,
  cumulative = counts,
  new = c(NA, diff(counts))
)

# cumulative plot
ggplot(df, aes(x = year, y = cumulative)) +
  geom_line(color = "darkred", size = 1) +
  geom_point(color = "darkred") +
  labs(title = "Oak wilt: cumulative infected cells", x = "Year", y = "Infected cells") +
  theme_minimal()

# new infections (incidence) bar plot
ggplot(df[-1, ], aes(x = year, y = new)) +   # drop year 0 (NA)
  geom_col(fill = "steelblue") +
  labs(title = "New infected cells per year", x = "Year", y = "New infections") +
  theme_minimal()

```

spread animation gif

```{r}



#animate(hist_stack, pause = 0.5, n =2)




oak_bg <- oakdens
oak_bg[] <- oakdens[]

hist_stack2 <- hist_stack
hist_stack2[hist_stack2 == 0] <- NA

composite <- rast(hist_stack2)

for (i in 1:nlyr(hist_stack2)) {
  r <- hist_stack2[[i]]

  # combine: background + infection
  composite[[i]] <- cover(r * 2, oakdens)
}


# animate(composite, pause = 0.5, col = c(terrain.colors(100), "red"),   legend = FALSE)

# suppressWarnings(
#   save_gif(
#     animate(composite, pause = 0.5, col = c(terrain.colors(100), "red"), legend = FALSE),
#     gif_file = "animations/Oak_Spread.gif"
#   )
# )

```





```{r}

# Run all four simulation variants for a list of campsites and save results
#
# Assumes these objects and functions already exist in your session:
# - oakdens            : SpatRaster (density)
# - dem                : SpatRaster (aligned to oakdens)
# - dens_vals          : numeric vector length ncell(oakdens)
# - adj_pairs_dir      : directed adjacency matrix (from,to)
# - soil_raster        : SpatRaster of soil multipliers (aligned or will be resampled)
# - trans_fun_base, trans_fun_slope, trans_fun_ss, trans_fun_full
# - camps_sub          : data.frame with columns Longitude, Latitude, Island, Site.., etc.
#
# Output:
# - Writes per-camp results to out_dir/<camp_name>/<func_name>_final.tif and <func_name>_counts.csv
# - Saves full R objects (RDS) as out_dir/<camp_name>/<func_name>.rds
#
# Example:
campslist <- camps_sub |> filter(Island == "Oak")
# Then run this script.


library(sf)
library(terra)

run_sims_for_camps <- function(camps_df,
                               oakdens,
                               dem,
                               dens_vals,
                               adj_pairs_dir,
                               soil_mult = soil_raster,
                               out_dir = "Results/simulations",
                               sim_funcs = c("base", "slope", "ss", "full"),
                               max_steps = 100,
                               verbose = TRUE,
                               ...) {
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # Prepare camps as sf (assume camps_df has Longitude/Latitude in decimal degrees)
  if (!("Longitude" %in% names(camps_df) && "Latitude" %in% names(camps_df))) {
    stop("camps_df must contain Longitude and Latitude columns")
  }
  camps_sf <- st_as_sf(camps_df, coords = c("Longitude", "Latitude"), crs = 4326, remove = FALSE)

  # Transform camps to oakdens CRS so cellFromXY works
  oak_crs <- crs(oakdens)           # terra CRS string
  if (!is.na(oak_crs) && nzchar(oak_crs)) {
    camps_sf <- st_transform(camps_sf, crs = oak_crs)
  } else {
    warning("oakdens has no CRS. Using camps coordinates as-is.")
  }

  # Map friendly function names to actual functions
  func_map <- list(
    base   = trans_fun_base,
    slope  = trans_fun_slope,
    ss     = trans_fun_ss,
    full   = trans_fun_full
  )
  sim_funcs <- intersect(sim_funcs, names(func_map))
  if (length(sim_funcs) == 0) stop("No simulation functions selected or available.")

  results_index <- list()

  for (i in seq_len(nrow(camps_sf))) {
    camp <- camps_sf[i, , drop = FALSE]

    camp_name <- if ("Location" %in% names(camp)) {
      make.names(as.character(camp$Location))
    } else if ("Site.." %in% names(camp)) {
      make.names(as.character(camp$Site..))
    } else {
      make.names(paste0(camp$Island, "_", i))
    }
    camp_dir <- file.path(out_dir, camp_name)
    if (!dir.exists(camp_dir)) dir.create(camp_dir, recursive = TRUE)

    start_xy <- st_coordinates(camp)
    start_cell <- cellFromXY(oakdens, start_xy)
    if (is.na(start_cell) || length(start_cell) == 0) {
      warning("Could not determine start cell for camp ", camp_name, "; skipping.")
      next
    }

    if (verbose) message("Running simulations for ", camp_name, " (start_cell=", start_cell, ")")

    camp_results <- list()

    for (fn in sim_funcs) {
      sim_fun <- func_map[[fn]]
      out_prefix <- file.path(camp_dir, fn)

      if (verbose) message(" - running: ", fn)

      # Build a candidate arg list with all possibly useful objects
      candidate_args <- list(
        oakdens = oakdens,
        dens_vals = dens_vals,
        dem = dem,
        soil_mult = soil_mult,
        adj_pairs_dir = adj_pairs_dir,
        start_cell = start_cell,
        max_steps = max_steps,
        verbose = verbose,
        ...
      )

      # Keep only args that the function actually declares
      f_args <- names(formals(sim_fun))
      # formals() can include ... so keep ... if present
      if ("..." %in% f_args) {
        call_args <- candidate_args
      } else {
        call_args <- candidate_args[names(candidate_args) %in% f_args]
      }

      # Call the function safely
      res <- tryCatch(
        {
          do.call(sim_fun, call_args)
        },
        error = function(e) {
          warning(sprintf("Simulation '%s' failed for camp '%s': %s", fn, camp_name, conditionMessage(e)))
          return(NULL)
        }
      )

      if (is.null(res)) next

      # store result
      camp_results[[fn]] <- res

      # Save final raster if present
      if (!is.null(res$final) && inherits(res$final, "SpatRaster")) {
        final_path <- paste0(out_prefix, "_final.tif")
        tryCatch({
          writeRaster(res$final, filename = final_path, overwrite = TRUE)
        }, error = function(e) warning("Failed to write final raster: ", conditionMessage(e)))
      }

      # Save counts table if present
      if (!is.null(res$counts)) {
        counts_path <- paste0(out_prefix, "_counts.csv")
        tryCatch({
          if (is.data.frame(res$counts)) write.csv(res$counts, counts_path, row.names = FALSE)
          else saveRDS(res$counts, paste0(out_prefix, "_counts.rds"))
        }, error = function(e) warning("Failed to write counts: ", conditionMessage(e)))
      }

      # Save entire result object
      tryCatch({
        saveRDS(res, paste0(out_prefix, ".rds"))
      }, error = function(e) warning("Failed to save RDS: ", conditionMessage(e)))
    }

    results_index[[camp_name]] <- list(camp = camp, start_cell = start_cell, results = camp_results)
  }

  saveRDS(results_index, file = file.path(out_dir, "results_index.rds"))
  return(invisible(results_index))
}

# Example usage:
campslist <- camps_sub |> filter(Island == "Oak")
all_results <- run_sims_for_camps(
  camps_df = campslist,
  oakdens = oakdens,
  dem = dem,
  dens_vals = dens_vals,
  adj_pairs_dir = adj_pairs_dir,
  soil_mult = soil_raster,
  out_dir = "Results/simulations/oak_island",
  sim_funcs = c("base", "slope", "ss", "full"),
  max_steps = 20,
  # extra args forwarded to functions, e.g.:
  beta = log(2) / 50,
  density_power = 1.5,
  jump_enabled = TRUE,
  jump_radius = 600,
  jump_beta = 0.005,
  verbose = TRUE
)




```


```{r}


fix_results_counts <- function(results_index, sims = c("base","slope","ss","full")) {
  for (camp_name in names(results_index)) {
    res_list <- results_index[[camp_name]]$results
    if (is.null(res_list)) next
    for (sim in sims) {
      res <- res_list[[sim]]
      if (is.null(res) || is.null(res$counts)) next
      counts <- as.data.frame(res$counts)

      # ensure step
      if (!("step" %in% names(counts))) counts$step <- seq_len(nrow(counts))

      # add cum_total if missing
      if (!("cum_total" %in% names(counts))) {
        if (all(c("cum_local","cum_jump") %in% names(counts))) {
          counts$cum_total <- counts$cum_local + counts$cum_jump
        } else if ("new_total" %in% names(counts)) {
          counts$cum_total <- cumsum(replace_na(counts$new_total, 0))
        } else if (all(c("new_local","new_jump") %in% names(counts))) {
          counts$cum_total <- cumsum(replace_na(counts$new_local, 0) + replace_na(counts$new_jump, 0))
        } else if ("new" %in% names(counts)) {
          counts$cum_total <- cumsum(replace_na(counts$new, 0))
        } else if ("cumulative" %in% names(counts)) {
          counts$cum_total <- counts$cumulative
        } else {
          # fallback: cumulative sum of any column that looks like new_* or total
          possible_new <- names(counts)[grepl("^new", names(counts))]
          if (length(possible_new) > 0) {
            counts$cum_total <- cumsum(rowSums(replace_na(counts[possible_new], 0)))
          } else {
            # if nothing suitable, create a zero series
            counts$cum_total <- rep(0L, nrow(counts))
          }
        }
      }

      # write back
      results_index[[camp_name]]$results[[sim]]$counts <- counts
    }
  }
  invisible(results_index)
}

# Run the fixer
results_index <- fix_results_counts(results_index)


```



```{r}
plot_compare_models_per_camp_v2 <- function(results_index,
                                            sim_funcs = c("base","slope","ss","full"),
                                            camps = NULL,
                                            ncol = 3,
                                            scale_free = FALSE,
                                            colors = c(base = "#1b9e77", slope = "#d95f02", ss = "#7570b3", full = "#e7298a"),
                                            show_points = FALSE,
                                            out_dir = NULL   # folder where run_sims_for_camps wrote per-camp CSVs (optional)
) {
  df_list <- list()

  for (camp_name in names(results_index)) {
    if (!is.null(camps) && !(camp_name %in% camps)) next
    res_list <- results_index[[camp_name]]$results
    if (is.null(res_list)) next

    for (sim in sim_funcs) {
      counts <- NULL
      # try in-memory first
      if (!is.null(res_list[[sim]]) && !is.null(res_list[[sim]]$counts)) {
        counts <- as.data.frame(res_list[[sim]]$counts)
      } else if (!is.null(out_dir)) {
        # try read CSV fallback
        csv_path <- file.path(out_dir, camp_name, paste0(sim, "_counts.csv"))
        if (file.exists(csv_path)) {
          counts <- tryCatch(read.csv(csv_path, stringsAsFactors = FALSE), error = function(e) NULL)
        }
      }
      if (is.null(counts)) next

      # Build cumulative series - be flexible about column names
      if ("cum_total" %in% names(counts)) {
        cum <- counts$cum_total
        step <- if ("step" %in% names(counts)) counts$step else seq_along(cum)
      } else if ("cumulative" %in% names(counts)) {
        cum <- counts$cumulative
        step <- if ("step" %in% names(counts)) counts$step else seq_along(cum)
      } else if (all(c("cum_local","cum_jump") %in% names(counts))) {
        cum <- counts$cum_local + counts$cum_jump
        step <- if ("step" %in% names(counts)) counts$step else seq_along(cum)
      } else if ("new_total" %in% names(counts)) {
        cum <- cumsum(replace_na(counts$new_total, 0))
        step <- if ("step" %in% names(counts)) counts$step else seq_along(cum)
      } else if (all(c("new_local","new_jump") %in% names(counts))) {
        cum <- cumsum(replace_na(counts$new_local, 0) + replace_na(counts$new_jump, 0))
        step <- if ("step" %in% names(counts)) counts$step else seq_along(cum)
      } else if ("new" %in% names(counts)) {
        cum <- cumsum(replace_na(counts$new, 0))
        step <- if ("step" %in% names(counts)) counts$step else seq_along(cum)
      } else {
        next
      }

      df_list[[paste(camp_name, sim, sep = "___")]] <- tibble(
        camp = camp_name,
        sim = sim,
        step = step,
        cum_total = cum
      )
    }
  }

  df <- bind_rows(df_list)
  if (nrow(df) == 0) stop("No cumulative data found. Run the diagnostics to see where counts are stored.")

  df$sim <- factor(as.character(df$sim), levels = sim_funcs)

  # ensure colour mapping
  if (!all(levels(df$sim) %in% names(colors))) {
    palette_vals <- RColorBrewer::brewer.pal(max(3, length(levels(df$sim))), "Set1")
    names(palette_vals) <- levels(df$sim)
    colors <- palette_vals
  } else {
    colors <- colors[levels(df$sim)]
  }

  p <- ggplot(df, aes(x = step, y = cum_total, color = sim)) +
    geom_line(size = 0.9) +
    { if (show_points) geom_point(size = 0.8) } +
    facet_wrap(~ camp, scales = if (scale_free) "free_y" else "fixed", ncol = ncol) +
    scale_color_manual(values = colors, name = "Model") +
    labs(x = "Step", y = "Cumulative infected (cells)",
         title = "Cumulative infected over time â€” model comparison",
         subtitle = paste0("Simulations: ", paste(sim_funcs, collapse = ", "))) +
    theme_minimal() +
    theme(strip.text = element_text(size = 9),
          legend.position = "bottom")

  return(p)
}

# Example: plot all camps, all four models, 3 columns per page
p <- plot_compare_models_per_camp_v2(
  results_index,
  sim_funcs = c("base","slope","ss","full"),
  ncol = 3,
  scale_free = FALSE,
  show_points = FALSE,
  out_dir = NULL   # only needed if you want on-disk CSV fallback
)

# view
print(p)

```





```{r}

```




