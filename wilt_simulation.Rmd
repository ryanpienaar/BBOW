---
title: "Oak_Wilt_Simulation"
author: "Ryan Pienaar"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

library(terra)
library(leaflet)
library(tmap)
library(tidyverse)
library(gganimate)
library(raster)

```

```{r}

oakdenspath <- "G:/My Drive/BBOW EE RASTERS/Oak_Predicted_Density.tif"
#oakdenspath <- "Y:/rpienaar/Apostle Islands/Map/Apostle_Islands_Map/Oak_Predicted_Density_Cli.tif"
oakdens <- rast(oakdenspath)

plot(oakdens)


# Create a leaflet map object
m <- leaflet() %>% addTiles()

# Create a color palette based on your raster's values
pal <- colorNumeric(c("red", "purple", "blue"), values(oakdens), na.color = "transparent")

m %>%
  addRasterImage(oakdens, colors = pal, opacity = 0.8) %>%
  addLegend(pal = pal, values = values(oakdens),
            title = "Your Legend Title")

```

```{r}

densdf <- as.data.frame(oakdens, xy = TRUE)
head(densdf)

```

Initialize infection

```{r}

set.seed(42)
infected <- oakdens * 0
park <- vect("Y:/rpienaar/Apostle Islands/Map/Apostle_Islands_Map/Admin_Shapefiles/Apostle Islands National Lakeshore.shp")
if (!identical(crs(infected), crs(park))) park <- project(park, crs(infected))
infected <- crop(infected, park)
infected <- mask(infected, park)

# find non-NA cells (inside park) and pick one at random
valid_cells <- which(!is.na(infected[]))
chosen <- sample(valid_cells, 1)

infected[chosen] <- 1
inf_initial <- infected
infected_r <- raster(infected)
# get cell centroid in raster CRS
cent <- xyFromCell(infected_r, chosen)

# transform centroid to lon/lat (WGS84) if raster is projected
cent_sp <- SpatialPoints(matrix(cent, ncol = 2), proj4string = crs(infected_r))
cent_ll  <- spTransform(cent_sp, CRS("+proj=longlat +datum=WGS84"))
cent_coords <- coordinates(cent_ll)[1, ]

# palette (NA transparent)
pal <- colorFactor(c("green","red"), domain = c(0,1), na.color = "transparent")

# map: raster + red circle marker over the infected cell
leaflet() %>%
  addTiles() %>%
  addRasterImage(infected_r, colors = pal, opacity = 0.9, project = FALSE) %>%
  addCircleMarkers(lng = cent_coords[1], lat = cent_coords[2],
                   radius = 8, color = "red", fill = TRUE, fillOpacity = 1, stroke = FALSE) %>%
  addLegend(pal = pal, values = c(0,1), labels = c("Uninfected","Infected"))
```
Base Model

```{r}

# infected: SpatRaster with values 0/1 and NA outside park
# If you currently have a raster::RasterLayer, convert:
# infected <- rast(infected_r)

# ensure values are numeric 0/1
infected[] <- as.integer(infected[])

years <- 20
w <- matrix(1, 3, 3)   # 3x3 window => queen neighbourhood

# optional: store snapshots (if you want to inspect each year)
snapshots <- list()
snapshots[[1]] <- infected

for (yr in 1:years) {
  # neighbourhood max: 1 if any neighbour (or the cell itself) is infected
  neigh_max <- focal(infected, w = w, fun = max, na.rm = TRUE)
  
  # ensure we keep NA outside park: force neigh_max to NA where raster is NA
  neigh_max[is.na(infected)] <- NA
  
  # logical raster: should be infected after this year (1 if any neighbour==1)
  will_be_infected <- neigh_max == 1
  
  # numeric 0/1 raster (keep NA)
  will_be_infected_num <- will_be_infected
  will_be_infected_num[] <- as.integer(values(will_be_infected))
  
  # update: keep previously infected, and infect any cell that will_be_infected
  old_vals <- values(infected)
  new_vals <- values(will_be_infected_num)
  updated <- pmax(old_vals, new_vals, na.rm = TRUE)
  # preserve NA mask (cells that were NA should stay NA)
  updated[is.na(old_vals)] <- NA
  
  # write back to raster
  infected[] <- updated
  
  snapshots[[yr + 1]] <- infected
  
  # check if any new infection occurred; break if none
  if (all(updated == old_vals, na.rm = TRUE)) {
    message("No new infections at year ", yr, "; stopping early.")
    break
  }
  
  message("Year ", yr, " done; infected cells: ", sum(values(infected) == 1, na.rm = TRUE))
}

# 'infected' now contains the final state, 'snapshots' has yearly rasters (1..N)

```

Base Model

```{r}
# Minimal Shiny app to step through snapshots
# Requires: shiny, leaflet, raster, terra, sp

library(shiny)
library(leaflet)
library(raster)
library(terra)
library(sp)

# prepare raster frames on disk or in memory
# convert snapshots to raster::RasterLayer and store in a list
r_list <- lapply(snapshots, function(x) raster(x))  # snapshots[[1]] = year 0

ui <- fluidPage(
  titlePanel("Infection spread â€” step through years"),
  sidebarLayout(
    sidebarPanel(
      sliderInput("year", "Year", min = 0, max = length(r_list) - 1, value = 0, step = 1, animate = animationOptions(interval = 800))
    ),
    mainPanel(
      leafletOutput("map", height = "700px")
    )
  )
)

server <- function(input, output, session) {
  pal <- colorFactor(c("green", "red"), domain = c(0,1), na.color = "transparent")

  output$map <- renderLeaflet({
    leaflet() %>%
      addTiles() %>%
      setView(lng = -91.0, lat = 46.95, zoom = 10)  # adjust center/zoom to your area
  })

  observe({
    yr <- input$year
    r <- r_list[[yr + 1]]   # list index
    leafletProxy("map", data = r) %>%
      clearImages() %>%
      addRasterImage(r, colors = pal, opacity = 0.9, project = FALSE) %>%
      clearControls() %>%
      addLegend(pal = pal, values = c(0,1), labels = c("Uninfected","Infected"), position = "bottomright")
  })
}

# runApp(list(ui = ui, server = server))
```

Align rasters

```{r}

# project oakdens to the infected CRS (if different)
if (!compareGeom(infected, oakdens, stopOnError = FALSE, crs = TRUE)) {
  oakdens_proj <- project(oakdens, infected, method = "bilinear")   # continuous => bilinear
} else {
  oakdens_proj <- oakdens
}

# resample oakdens to the exact grid (extent, resolution, origin) of infected
# This will align the cells and extent to be identical to 'infected'
oakdens_aligned <- resample(oakdens_proj, infected, method = "bilinear")
oakdens <- oakdens_aligned

```


Parameterized model

```{r}



# Simulate infection spread with transmission probability dependent on oak density
#
# Requires: terra
# Inputs expected in the environment:
# - infected_r : RasterLayer (from raster) or SpatRaster with values 0/1 and NA outside park
# - oakdens    : RasterLayer or SpatRaster with oak density (numeric) and same extent/resolution/mask as infected_r
#
# Behaviour:
# - For each susceptible cell, consider all 8 neighbours + itself (3x3 queen neighbourhood).
# - For each infected neighbour i, compute a transmission probability p_i that depends on
#   the oak density of the infected neighbour (d_src) and the focal target cell (d_tgt).
# - The cell becomes infected with probability 1 - prod_i (1 - p_i), i.e. probability at least one neighbour transmits.
# - Already infected cells remain infected.
# - Cells that are NA in the original infected raster stay NA.
#
# Parameters to tune:
# - years: number of years to simulate
# - beta: transmission scaling parameter (higher -> higher probabilities)
# - transmission_fun: function(d_src, d_tgt, beta) returning a probability in [0,1]
# - seed: optional RNG seed for reproducible stochastic runs
#
# Example usage:
# infected <- rast(infected_r)     # convert if needed
# oakdens  <- rast(oakdens_r)
# source("infectious_spread_with_oak_density.R")
# res <- simulate_spread(infected, oakdens, years = 50, beta = 1.0, seed = 42)


simulate_spread <- function(infected,
                            oakdens,
                            years = 50,
                            beta = 1.0,
                            transmission_fun = NULL,
                            seed = NULL,
                            store_snapshots = TRUE,
                            verbose = TRUE) {
  # Input checks
  if (!inherits(infected, "SpatRaster")) infected <- rast(infected)
  if (!inherits(oakdens, "SpatRaster"))  oakdens  <- rast(oakdens)
  if (!compareGeom(infected, oakdens, stopOnError = FALSE)) {
    stop("infected and oakdens must have the same extent, resolution and CRS")
  }
  # ensure integer 0/1 and keep NA mask
  infected[] <- as.integer(values(infected))
  
  # default transmission function if not provided:
  # uses average density of source and target, scaled by beta, with a saturating transform
  # p = 1 - exp(-beta * (d_src + d_tgt)/2)
  if (is.null(transmission_fun)) {
    transmission_fun <- function(d_src, d_tgt, beta) {
      mu <- (d_src + d_tgt) / 2
      # ensure non-negative
      mu[is.na(mu)] <- 0
      p <- 1 - exp(-beta * mu)
      p[p < 0] <- 0
      p[p > 1] <- 1
      return(p)
    }
  }
  
  # window for queen neighbourhood (3x3)
  w <- matrix(1, 3, 3)
  
  # snapshots
  snapshots <- list()
  if (store_snapshots) snapshots[[1]] <- infected
  
  # option for reproducibility
  if (!is.null(seed)) set.seed(seed)
  
  # Precompute oak density values matrix to allow fast indexing if needed
  # But using terra::focal we can compute neighbourhood-based operations.
  # We'll iterate years and for each susceptible cell:
  # - collect infected neighbours (3x3 binary)
  # - extract d_src values for neighbours and d_tgt (center)
  # - compute p_i for each infected neighbour, aggregate to overall probability
  #
  # Implementation detail:
  # We will use focal() to get, for each focal cell, the 3x3 values of infected and oakdens
  # However terra::focal returns a single summary per cell. To get full neighbourhood matrices
  # we will extract cell indices of all neighbours once and use adjacent() combined with values().
  #
  # For clarity and correctness (and because raster sizes can be moderate), we implement neighbour
  # enumeration via terra::adjacent which is memory efficient.
  
  # Prepare index mapping
  ncell <- ncell(infected)
  cells_idx <- 1:ncell
  
  # Precompute adjacency lists (queen = TRUE)
  # adjacent returns a matrix with from,to pairs. We'll convert to a list: for each target cell, the vector of neighbour cell indices (including itself).
  if (verbose) message("Computing adjacency (neighbour) lists...")
  adj_pairs <- adjacent(infected, cells = cells_idx, directions = 8, pairs = TRUE, include = TRUE)
  # adjacent(..., include = TRUE) will include self as neighbour in some versions; if not, we'll add it.
  # adj_pairs: matrix with two columns: from, to
  # We want for each target (to) the list of 'from' neighbours
  neigh_list <- vector("list", ncell)
  # adj_pairs might be a two-column matrix or data.frame
  adj_from <- adj_pairs[,1]
  adj_to   <- adj_pairs[,2]
  for (i in seq_along(adj_from)) {
    t <- adj_to[i]
    neigh_list[[t]] <- c(neigh_list[[t]], adj_from[i])
  }
  # Ensure self is included (some terra versions' adjacent(..., include=TRUE) already includes)
  for (cell in cells_idx) {
    if (!(cell %in% neigh_list[[cell]])) neigh_list[[cell]] <- c(neigh_list[[cell]], cell)
  }
  
  # get initial values as vectors for fast operations
  infected_vals <- values(infected)   # integer 0/1/NA
  oak_vals      <- values(oakdens)    # numeric, NA outside park possibly
  
  if (verbose) message("Starting simulation for up to ", years, " years...")
  for (yr in seq_len(years)) {
    old_vals <- infected_vals  # 0/1/NA
    # will hold next state
    new_vals <- old_vals
    
    # For each not-yet-infected but non-NA cell, compute infection probability from infected neighbours
    susceptible_idx <- which(!is.na(old_vals) & old_vals == 0)
    if (length(susceptible_idx) == 0) {
      if (verbose) message("No susceptible cells remain at year ", yr - 1, "; stopping.")
      break
    }
    
    # We'll vectorize across susceptible cells in a loop -- could be parallelized if needed
    for (cell in susceptible_idx) {
      neighs <- neigh_list[[cell]]
      # infected neighbours (exclude NA neighbours)
      neigh_infected_mask <- !is.na(old_vals[neighs]) & (old_vals[neighs] == 1)
      if (!any(neigh_infected_mask)) next  # no infected neighbours -> remains susceptible
      
      infected_neigh_ids <- neighs[neigh_infected_mask]
      # densities
      d_src <- oak_vals[infected_neigh_ids]   # source densities
      d_tgt <- oak_vals[cell]                 # target density (single value)
      # handle possible NA densities: if either NA, treat density as 0 for transmission calc (or you can choose another rule)
      # here we treat NA as 0 to avoid NA probabilities
      d_src[is.na(d_src)] <- 0
      if (is.na(d_tgt)) d_tgt <- 0
      
      # compute p_i for each infected neighbour
      p_i <- transmission_fun(d_src, d_tgt, beta)
      # ensure within [0,1]
      p_i[is.na(p_i)] <- 0
      p_i[p_i < 0] <- 0
      p_i[p_i > 1] <- 1
      
      # combined probability that at least one neighbour transmits:
      p_any <- 1 - prod(1 - p_i)
      
      # stochastic infection: sample Bernoulli(p_any)
      if (runif(1) < p_any) {
        new_vals[cell] <- 1L
      } else {
        new_vals[cell] <- 0L
      }
    } # end per-susceptible cell loop
    
    # preserve NA mask: ensure cells that were NA remain NA
    new_vals[is.na(old_vals)] <- NA_integer_
    
    infected_vals <- new_vals
    
    # check for changes
    changed <- !identical(new_vals, old_vals)
    # update raster object values
    infected[] <- infected_vals
    
    if (store_snapshots) snapshots[[yr + 1]] <- infected
    
    # progress messages
    if (verbose) {
      n_infected <- sum(infected_vals == 1, na.rm = TRUE)
      message("Year ", yr, " done; infected cells: ", n_infected)
    }
    
    # stop early if no new infections occurred
    if (!changed) {
      if (verbose) message("No new infections at year ", yr, "; stopping early.")
      break
    }
  } # end years loop
  
  # return results
  return(list(final = infected,
              snapshots = if (store_snapshots) snapshots else NULL,
              params = list(years = years, beta = beta),
              oakdens = oakdens))
}

# Example of a custom transmission function you might want to use:
# - linear combination: p = min(1, beta * (alpha_src * d_src + alpha_tgt * d_tgt))
# - or make transmission mostly driven by source density:
example_trans_fun <- function(d_src, d_tgt, beta) {
  # alpha weights
  alpha_src <- 0.7
  alpha_tgt <- 0.3
  p_raw <- beta * (alpha_src * d_src + alpha_tgt * d_tgt)
  p <- pmin(1, p_raw)
  p[is.na(p)] <- 0
  p
}

# End of file

```

```{r}

# keep example_trans_fun defined as earlier:
# example_trans_fun <- function(d_src, d_tgt, beta) { ... }

# pass a function (do not call example_trans_fun)
res <- simulate_spread(
  inf_initial,
  oakdens_aligned,
  years = 10,
  transmission_fun = function(d_src, d_tgt, beta) example_trans_fun(d_src, d_tgt, 1),
  seed = 42
)


```

```{r}

```

